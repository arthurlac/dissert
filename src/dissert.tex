\documentclass[a4paper,10pt]{article}
\usepackage{amsmath}
\usepackage{listings}

\title{A comparison of algebraic effects and monads}
\author{Arthur}
\date{\today}

\setlength{\parindent}{1em}
\setlength{\parskip}{1em}

\begin{document}
\maketitle
\section{Abstract}

I will explore both the relation and use of monads and algebraic effects,
illustrating this through rewriting a scheduling application which uses
monadic concurrency to use alegbraic effects; examining the tradeoffs made.
I will also try to establish the theoretical foundations of these concepts.

\section{Overview}
Moggi \cite{Moggi:hc} introduced the computational lambda calculus (${\lambda}_c$-calculus)
and computational monads. Demonstrating non-determinism, side-effects, and continuations.

In pure function functional languages monads have become the de facto abstraction for effects.
This practise was established in this paper \cite{wadler1990}.

Algebraic effects \cite{plotkin2001adequacy} and their handlers \cite{Plotkin:2001jr}
can be used for non-determinism, side-effects, and continuations just like monads.
Algebraic effects have seen a rise in popularity in functional programming languages.
With effect handlers programs can be written in an imperative direct style.
In my dissertation I will try to ascertain the state of the art in this area.
See \cite{Bauer:2013fn, leijen:16, Lindley:2016vz, Dolan:2017} and more.

\section{Monads}

Moggi \cite{moggi} defines a monad over a category $\mathcal{C}$ as a triple
$(T,\eta,\mu)$, where

\begin{equation}
  \begin{split}
    T    &:: \mathcal{C} \rightarrow \mathcal{C} \\
    \eta &:: Id_{\mathcal{C}} \rightarrow T       \\
    \mu  &:: T^{2} \rightarrow T
  \end{split}
\end{equation}
and the following holds
\begin{equation}
  \begin{split}
    \eta &:: Id_{\mathcal{C}} \rightarrow T       \\
    \mu  &:: T^{2} \rightarrow T
  \end{split}
\end{equation}

Typically a programmer will think of a monad as a signature of three
functions:

\begin{equation}
  \begin{split}
    unit &:: x \rightarrow M x                                 \\
    map  &:: (x \rightarrow y) \rightarrow M x \rightarrow M y \\
    join &:: M (M x) \rightarrow M x
  \end{split}
\end{equation}

Unit is also sometimes referred to as return, as unit is also the type with a single inhabitant.
One may also see bind as which is similar to map.

\begin{equation}
  bind :: M x \rightarrow (x \rightarrow M y) \rightarrow M y
\end{equation}

\subsection{Use of monads}
Monads have multiple uses, 

Monads are frequently used to structure programs, in my scheduler example monads are
used for concurrency, error handling.

OCaml has non-nullable types i.e; one will never see null where one is expecting an
int or a binary tree or anything else.
Null values are explicit. The cannocical representation of null is the None variant.
Monads are used to structure computation with the option type.

\begin{verbatim}
  type 'a option = Some 'a | None
  val return : 'a -> 'a option
  val join   : 'a option option -> 'a option
  val map    : 'a option -> ('a -> 'b) -> 'b option
\end{verbatim}

Consider this example code for searching a trie data structure. Briefly,
a trie is key value data structure; where the key is a string (considered a
list of chars in this example). Each node has an option value and a list of
children. The root of the trie represents the empty string. Two auxillary
functions find child and val extract are used in the search code;
val extract simply returns the first value in a pair, find child searchs
the list of children returning the node with the matching character given
if the child exists.

\begin{verbatim}
  type ('c, 'v) t = Trie of 'v option * (('c * ('c, 'v) t) list)
  val find_child  : ('c, 'v) t -> 'c -> ('c, 'v) t option
  val val_extract : ('c, 'v) t -> 'v option
  val get         : ('c, 'v) t -> 'c list -> 'v option
\end{verbatim}

We use to bind as as infix operator \texttt{>>=} to structure the program.

In the search code t is the trie, key is a list of characters over which
we iterate the search function. For each character we call find child on
the current node. Find child, if succesful, will return the next node
upon which we continue the search with the remaining characters. Once we
are at the last character we know to try and extract the value from the end
node. The key point here is that using bind allows us to succintly only code
for the happy case but deal with the error case at every step.

\begin{verbatim}
  let get t key =
    let rec search chars t =
        match chars with
        | []      -> val_extract t
        | c :: cs -> bind_search (find_child t c) cs
    and bind_search ot chars = ot >>= search chars
    in search key t
\end{verbatim}

The result type is similar to the option type, however we use an extra type
parameter for the unhappy case, essentially the result type encapsulates 
either an error or a correct computation result.

\begin{verbatim}
  type ('a, 'e) result = Ok of 'a | Error of 'e
  val bind : ('a, 'e) result
          -> ('a -> ('b, 'e) result)
          -> ('b, 'e) result
\end{verbatim}

In this example we have a list assocation which is a list of pairs, in this case both
items in the pairs are strings.

\begin{verbatim}
  let list_assoc_to_job la =
    let find k = match List.Assoc.find la k with
      | None -> Error (Err.missing_key k)
      | Some v -> Ok v
    in
    find "name"   >>=                  (fun name   ->
    find "prog"   >>=                  (fun prog   ->
    find "args"   >>= parse_args   >>= (fun args   ->
    find "run_at" >>= parse_run_at >>= (fun run_at ->
      Ok (Job.create name prog args run_at ())
    ))))
\end{verbatim}

Bind is used to succintly short circuit a computation when a value can not be
correctly obtained. As such this allows the program to be structured neatly to return
an error with precise information for which key could not be found or which value could
not be parsed. The result monad is very similar to the option monad. It would be interesting
to examine whether algebraic effects can be used to structure a program in a similar manner.

\begin{verbatim}
  let rec schedule job =
    let time = Job.next_occur job in
    Async.run_at time Job.run job
    >>= schedule job
\end{verbatim}

These examples clearly illustrate how useful monads can be for structuring a program.

Monads are not just used to structure programs, they can be used for IO.

\section{Algebraic Effects}
\subsection{Use of algebraic effects}

\medskip

\bibliographystyle{unsrt}
\bibliography{dissert}

\end{document}
