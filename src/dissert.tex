\documentclass[a4paper,10pt]{article}
\usepackage{listings}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{mathtools}

\title{A comparison of algebraic effects and monads}
\author{Arthur}
\date{\today}

\setlength{\parindent}{1em}
\setlength{\parskip}{1em}

\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]
\newtheorem{example}{Example}[section]


\begin{document}
\maketitle
\section{Abstract}

I will explore both the relation and use of monads and algebraic effects,
illustrating this through rewriting a scheduling application which uses
monadic concurrency to use algebraic effects; examining the trade-offs made.
I will also try to establish the theoretical foundations of these concepts.

Effects are tricky, and essential , programmers have long sought to make them more predictable
this comes at costs.

\section{Monads}

Moggi \cite{moggi1989computational} introduced a categorical semantics of computation
based on monads. Moggi defines a monad over a category $\mathcal{C}$ as a triple $(T,\eta,\mu)$,
where $T$ is a functor, $\eta$ and $\mu$ are natural transformations. He further defines a
a computational model which allows computations with effects such as non-deterministic 
computation, side effects, and continuations.

\begin{equation}
  \begin{split}
    T    &:: \mathcal{C} \rightarrow \mathcal{C} \\
    \eta &:: Id_c \rightarrow T                  \\
    \mu  &:: T^2 \rightarrow T
  \end{split}
\end{equation}

Typically a programmer will think of a monad as three function signatures
which correspond to the triple defined by Moggi; of course much more
informally, \texttt{fmap} coresponds to the functor $T$, \texttt{return} and \texttt{join} to the
natural transformations $\eta$ and $\mu$ respectively.

\begin{equation}
  \begin{split}
    fmap   &:: M x \rightarrow (x \rightarrow y) \rightarrow M y \\
    return &:: x \rightarrow M x                                 \\
    join   &:: M (M x) \rightarrow M x
  \end{split}
\end{equation}

One may also see \texttt{bind} which is similar to $fmap$.
Bind is typically used as an infix operator, we shall use $\gg$ as a binary
operator for bind.

\begin{equation}
  bind :: M x \rightarrow (x \rightarrow M y) \rightarrow M y
\end{equation}

Bind is effectively $\lambda x. \lambda f.join (fmap (\lambda z. return (f z)) x$,
it exists largely for programmer convenience to avoid using fmap when the

Monad laws
\begin{itemize}
	\item Left identity - $(return\ a) \gg f = f a$
	\item Right identity - $m \gg return = m$
	\item Associativity - $(m \gg f) \gg g = m \gg (\lambda x \rightarrow f x \gg g)$
\end{itemize}

Note that these axioms mirror those of a monoid $(M,\ \cdot,\ e)$,
where \textit{bind} corresponds to $\cdot$ and
$e$ corresponds to \textit{return} such that
$$\forall\ x, y, z \in M\ (x \cdot y) \cdot z = x \cdot (y \cdot z)$$
$$\forall\ m \in M\ m \cdot e = e \cdot m = m$$

\subsection{Use of monads}
Wadler \cite{wadler1990comprehending} demonstrated the use of monads in a pure
functional programming language to simulate effects. I will explore examples similar to
the exception monads Wadler presents. Monads are frequently used
to structure programs. For example OCaml has non-nullable types
i.e; one will never see null where one is expecting an
int or a binary tree or anything else.
Null values are explicit. The cannocical representation of null is the None variant.
Monads are used to structure computation with the option type.

\begin{verbatim}
  type 'a option = Some 'a | None
  val return : 'a -> 'a option
  val join   : 'a option option -> 'a option
  val map    : 'a option -> ('a -> 'b) -> 'b option
\end{verbatim}

Consider this example code for searching a trie data structure. Briefly,
a trie is key value data structure; where the key is a string (considered a
list of chars in this example). Each node has an option value and a list of
children. The root of the trie represents the empty string. Two auxillary
functions find child and val extract are used in the search code;
val extract simply returns the first value in a pair, find child searchs
the list of children returning the node with the matching character given
if the child exists.

\begin{verbatim}
  type ('c, 'v) t = Trie of 'v option * (('c * ('c, 'v) t) list)
  val find_child  : ('c, 'v) t -> 'c -> ('c, 'v) t option
  val val_extract : ('c, 'v) t -> 'v option
  val get         : ('c, 'v) t -> 'c list -> 'v option
\end{verbatim}

We use to bind as as infix operator \texttt{>>=} to structure the program.

In the search code t is the trie, key is a list of characters over which
we iterate the search function. For each character we call find child on
the current node. Find child, if succesful, will return the next node
upon which we continue the search with the remaining characters. Once we
are at the last character we know to try and extract the value from the end
node. The key point here is that using bind allows us to succintly only code
for the happy case but deal with the error case at every step.

\begin{verbatim}
  let get t key =
    let rec search chars t =
        match chars with
        | []      -> val_extract t
        | c :: cs -> bind_search (find_child t c) cs
    and bind_search ot chars = ot >>= search chars
    in search key t
\end{verbatim}

The result type is similar to the option type, however we use an extra type
parameter for the unhappy case, essentially the result type encapsulates 
either an error or a correct computation result. The result monad
corresponds to a generalisation of the exception monad presented by Wadler \cite{wadler1995monads}.

\begin{verbatim}
  type ('a, 'e) result = Ok of 'a | Error of 'e
  val bind : ('a, 'e) result
          -> ('a -> ('b, 'e) result)
          -> ('b, 'e) result
\end{verbatim}

In this example we have a list assocation which is a list of pairs, in this case both
items in the pairs are strings.

\begin{verbatim}
  let list_assoc_to_job la =
    let find k = match List.Assoc.find la k with
      | None -> Error (Err.missing_key k)
      | Some v -> Ok v
    in
    find "name"   >>=                  (fun name   ->
    find "prog"   >>=                  (fun prog   ->
    find "args"   >>= parse_args   >>= (fun args   ->
    find "run_at" >>= parse_run_at >>= (fun run_at ->
      Ok (Job.create name prog args run_at ())
    ))))
\end{verbatim}

Bind is used to succintly short circuit a computation when a value can not be
correctly obtained. As such this allows the program to be structured neatly to return
an error with precise information for which key could not be found or which value could
not be parsed. The result monad is very similar to the option monad. It would be interesting
to examine whether algebraic effects can be used to structure a program in a similar manner.

These examples clearly illustrate how useful monads can be for structuring a program.

\section{Algebraic Effects}

Algebraic effects, like monads, can be used to model effects in a pure language.
In programming they are often paired with handlers, where algebraic operations construct effects
handlers are dual, they deconstruct effects \cite{plotkin2009handlers}.

"Algebraic effect handlers concisely describe many complex control-flow constructs
in various programming languages" \cite{leijen2017type}

"Algebraic effects and handlers provide a modular abstraction for expressing effectful computation,
allowing the programmer to separate the expression of an effectful computation from its implementation."
\cite{dolan2015effective}

"the signature of the effect operations forms a free algebra which gives rise to a free monad. Free monads provide a natural way to give semantics to effects, where handlers describe a fold over the algebra of operations [44]. Using a more operational perspective, we can also view algebraic effects as resumable exceptions (or perhaps as a more structured form of delimited continuations)." \cite{leijen2017type}


\medskip

\bibliographystyle{unsrt}
\bibliography{dissert}

\end{document}
