\documentclass[a4paper,10pt]{article}
\usepackage{amsmath}
\usepackage{listings}

\title{A comparison of algebraic effects and monads}
\author{Arthur}
\date{\today}

\setlength{\parindent}{1em}
\setlength{\parskip}{1em}

\begin{document}
\maketitle
\section{Abstract}

In the dissertation I will explore both the relation and use of monads and algebraic effects,
I will also try to establish the theoretical foundations of these concepts.
Finally I will present programs where monads and algebraic effects are equivalent or
inequivalent. Concluding with a discussion of the ramifications of the latter.

\section{Overview}
Moggi \cite{Moggi:hc} introduced the computational lambda calculus (${\lambda}_c$-calculus)
and computational monads. Demonstrating non-determinism, side-effects, and continuations.

In pure function functional languages monads have become the de facto abstraction for effects.
This practise was established in this paper \cite{wadler1990}.

Algebraic effects \cite{plotkin2001adequacy} and their handlers \cite{Plotkin:2001jr}
can be used for non-determinism, side-effects, and continuations just like monads.
Algebraic effects have seen a rise in popularity in functional programming languages.
With effect handlers programs can be written in an imperative direct style.
In my dissertation I will try to ascertain the state of the art in this area.
See \cite{Bauer:2013fn, leijen:16, Lindley:2016vz, Dolan:2017} and more.

A monad over a category $\mathcal{C}$ is a triple $(T,\eta,\mu)$. Where

\begin{equation}
  \begin{split}
    T    &:: \mathcal{C} \rightarrow \mathcal{C} \\
    \eta &:: Id_{\mathcal{C}} \rightarrow T       \\
    \mu  &:: T^{2} \rightarrow T
  \end{split}
\end{equation}
and the following holds
\begin{equation}
  \begin{split}
    \eta &:: Id_{\mathcal{C}} \rightarrow T       \\
    \mu  &:: T^{2} \rightarrow T
  \end{split}
\end{equation}


Typically a program will think

\begin{equation}
  \begin{split}
    unit &:: x \rightarrow M x                                 \\
    map  &:: (x \rightarrow y) \rightarrow M x \rightarrow M y \\
    join &:: M (M x) \rightarrow M x
  \end{split}
\end{equation}

One may also see

\begin{equation}
  bind :: M x \rightarrow (x \rightarrow M y) \rightarrow M y
\end{equation}

\section{Use of monads}
Monads are frequently used to structure programs, in my scheduler example monads are
used for concurrency, error handling. Consider this example.

\begin{lstlisting}
    let%bind name   =  find_essential "name"                     in
    let%bind prog   =  find_essential "prog"                     in
    let%bind args   = (find_essential "args"   >>= parse_args  ) in
    let%bind run_at = (find_essential "run_at" >>= parse_run_at) in
    (* Optionals, no monad trickiness *)
    let stdin  = find_optional "stdin"  in
    let stdout = find_optional "stdout" in
\end{lstlisting}



\medskip

\bibliographystyle{unsrt}
\bibliography{proposal}

\end{document}
