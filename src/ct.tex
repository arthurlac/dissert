\section{Categorical Views of Effects}

\subsection{Overview}
In this section we will explore the theoretical underpinnings of effects,
the two key theoretical concepts are monads and Lawvere theories.
For a prima facie understanding of we can say that
they share a mathematical relation in understanding and expressing aspects of universal algebra.
Where abstract algebra has specific algebraic structures, such as groups and rings,
universal algebra examines these structures in a general sense.
Not only do they share a history, finitary monads and Lawvere theories
"describe equivalent categorical encodings of universal algebra"\cite{riehl}.
%TODO
These ideas, while fascinating and perplexing,
are not central to this document.
% and is added for perspective.
% They have been discussed to enrich the perspectives discussed

Moggi in 1989 \cite{moggi1989computational}
first described the relation between monads and computational effects,
introducing the $\lambda_C$-calculus.
Serendipitously the Haskell programming language\cite{hudak1992report}
was being formulated in this same period of time.
As both a pure and lazy language
it could not have effects in the manner programmers were accustomed to thus far;
Moggi's $\lambda_C$-calculus was brought forth by Wadler\cite{wadler1990}
as an elegant solution to this problem.

Plotkin and Power \cite{Plotkin:2001jr}
introduced Lawvere theories to the discussion of effects
in the early 2000s,
contributing that monads were not effects themselves but rather were determined by effects;
effects arising from operations.

\subsection{Categories}
As one can guess from the name \textit{category theory},
categories are at the heart of the subject.
From this definition we will eventually arrive at monads.
A computer scientist can begin conceptually
understanding objects in a category
as an analogy to types
and morphisms as functions.

\begin{definition}
    A \textit{category} $C$ consists of
    \begin{itemize}
        \item A set $Ob\,C$, elements of which are called \textit{objects} of $C$.
        \item For each $X, Y \in Ob\,C$
            a set $Hom(X,Y)$ called the \textit{homset} from $X$ to $Y$.
        \item A \textit{composition function} $\circ$ such that
            \begin{equation}
                \circ : Hom(X,Y) \times Hom(Y,Z) \rightarrow Hom(X,Z)
            \end{equation}
        \item For all $X \in Ob\,C$ an element $Id_X$ of $Hom(X,\ X)$ such that
            \begin{equation}
            f \circ Id_X = Id_Y \circ f = f
            \end{equation}
        \item Composition is associative.  $f \circ (g \circ h) = (f \circ g) \circ h$
    \end{itemize}
\end{definition}

\par
An element $f$ of $Hom(X,Y)$ is called an \textit{arrow},
or a \textit{morphism}. The object $X$ is called the \textit{domain} of $f$ and $Y$ is
the \textit{codomain}.\\

\begin{example}
    The immediate example of a category is the category of sets.
    The objects in $C$ are (small) sets,
    a morphism from $X$ to $Y$ is a function $f : X \rightarrow Y$.
    The composition of Set is given by composition of functions,
    and the identity maps are given by the identity functions.
\end{example}

\subsection{Functors}
Functors are the next step in our journey,
and we can consider them a morphism between categories.\\

\begin{definition}
    A \textit{functor} $U : C \rightarrow D$ consists of
    \begin{itemize}
        \item A function $Ob\,U : Ob\,C \rightarrow Ob\,D$.
        \item A function $U : Hom_C(X,Y) \rightarrow Hom_D(UX, UY)$
            such that $U$ respects both composition and identity.
            I.e.
            \begin{equation}
                Uf \circ Ug = U(f \circ g)
            \end{equation}
            \begin{equation}
                U\,Id_X = Id_{UX}
            \end{equation}
    \end{itemize}
\end{definition}

\begin{definition}
    An \textit{endofunctor} is a functor $U : C \rightarrow C$;
    i.e. the domain and codomain of the functor are the same category $C$.
\end{definition}

\subsection{Natural transformations}
Just as we considered functors a morphism between categories,
we can in turn consider a natural transformation a morphism of functors.\\

\begin{definition}
    Given categories $C$ and $D$,
    with functors $U, V : C \rightarrow D$
    a \textit{natural transformation} $\alpha : U \rightarrow V$
    consists of
    \begin{equation}
        \forall\ X \in Ob\,C\ \textrm{a map} \ \alpha_X : UX \rightarrow VX
    \end{equation}
    such that $\forall\ f : X \rightarrow Y$ the following commutes
    \begin{center}
        \begin{tikzcd}[sep=large]
            UX \rar{\alpha_X} \dar[swap]{Uf} & VX \dar{Vf} \\
            UY \rar{\alpha_Y}                & VY
        \end{tikzcd}
    \end{center}
\end{definition}

\subsection{Monads}
Building upon our previous definitions we can define a monad.
Monads are a ubiquitous structure in category theory;
being central to the
"category-theoretic account of universal algebra"\cite{mac2013categories}.\\

\begin{definition}
    A \textit{monad} is defined as the triple
    \begin{itemize}
        \item An endofunctor $T : C \rightarrow C$
        \item A natural transformation $\eta : 1_{C} \rightarrow T$
        \item A natural transformation $\mu : T^2 \rightarrow T$
    \end{itemize}
    Such that the following diagrams commute
    \begin{center}
        \begin{tikzcd}[sep=large]
            T \rar{\eta_T} \drar[swap]{1_{C}} & T^2 \dar{\mu} & \lar[swap]{T\eta} \dlar{1_{C}} T \\
                                               & T            &
        \end{tikzcd}
        \quad
        \begin{tikzcd}[sep=large]
            T^3 \rar{T\mu} \dar[swap]{\mu_T} & T^2 \dar{\mu} \\
            T^2 \rar[swap]{\mu}                    & T
        \end{tikzcd}
    \end{center}
\end{definition}

\subsection{Kleisli Category}
\begin{definition}
    Given a monad $(T,\eta,\mu)$ over a category $C$,
    the \textit{Kleisli category} $C_T$ consists of
    \begin{itemize}
        \item Objects of $C_T$ are objects from the underlying category $C$.
        \item $Hom_{C_T}(X,Y) = Hom_C (X,TY)$
        \item Identity morphisms in $C_T$ are $\eta$ in $C$
        \item Composition $f \circ g$ is $\mu(Tf)g$
    \end{itemize}
\end{definition}

Composition in $C_T$ can be described in more detail via the operator
\begin{equation}
    (-)^{*} : Hom(X, TY) \rightarrow Hom(TX, TY)
\end{equation}
where given a morphism $f: X \rightarrow TY$ we have
\begin{equation}
    f^{*} = \mu_{Y} \circ Tf
\end{equation}
Note that
\begin{equation}
    \eta_{X}^{*} = Id_{TX}
    \quad\textrm{and}\quad
    f^{*} \circ \eta _{X} = f
\end{equation}
Then we can define the \textit{Kleisli operator} $\gg$ where
\begin{equation}
    g \gg f = g^{*} \circ f
\end{equation}
\begin{equation}
    x
    \stackrel{f}{\rightarrow}     T y
    \stackrel{T g}{\rightarrow}   T T z
    \stackrel{\mu z}{\rightarrow} T z
\end{equation}
where $\gg$ has these axioms
\begin{equation}
    (f \gg g) \gg h \equiv f \gg (g \gg h)
\end{equation}
\begin{equation}
    \eta_Y \gg f \equiv f \equiv f \gg \eta_X
\end{equation}

\subsection{Computational Lambda Calculus}
Moggi \cite{moggi1989computational}
introduced categorical semantics for computation based on monads.
He extended the simply typed lambda-calculus to
the computational lambda-calculus, or $\lambda_c$-calculus,
which allows computations with effects such as
non-determinism, side effects, and continuations.
In this model "a program denotes a morphism from $A$
(the object of values of type $A$) to $TB$
(the object of computations of type B)"
for example
"partial computations (of type $B$) is the lifting $B + \{\bot\}$".
A concrete example would be the type \texttt{IO Int}
meaning interactive input/output computations returning integers.
Whereas the simply typed lambda calculus is modeled by a cartesian closed category $C$;
a $\lambda_c$-model over a category $C$ with finite products is a strong monad $(T,\eta,\mu,t)$
together with a $T$-exponential for every pair $\langle A, B\rangle$ of objects in $C$
\cite{moggi1989computational}.

Here are two examples of the $\lambda_C$-calculus from
\cite{moggi1989computational}\cite{moggi1991notions}.
\vspace{5mm}

\begin{example}\label{lc1}
\end{example}
    Computations with side-effects:
    \begin{itemize}
        \item $T(-)$ is the functor $(-\times S)^S$, where $S$ is a nonempty set of stores.
            Intuitively a computation takes a store and returns a value together with the modified store.
        \item $\eta_A$ is the map $a \rightarrow (\lambda s:S.\langle a,s \rangle)$
        \item $\mu_A$ is the map $f \rightarrow (\lambda s:S.eval(fs))$,
            i.e. $\mu_A(f)$ is the computation that given a store $s$,
            first computes the pair computation-store $\langle f\prime,s\prime\rangle = fs$
            and then returns the pair value-store $\langle a,s\prime\prime\rangle = f\prime s\prime$.
    \end{itemize}
\vspace{5mm}

\begin{example}
    Non-deterministic computations:
    \begin{itemize}
        \item $T(-)$ is the covariant powerset functor,
            i.e.  $T(A)$ = $P(A)$ and $T(f)(X)$ is the image of X along f
        \item $\eta_A$ is the singleton map $a \mapsto  \{a\}$
        \item $\mu_A(X)$ is the big union $\bigcup X$
    \end{itemize}
\end{example}

\subsection{Lawvere Theories}
The semantics of algebraic effects have a categorical basis as
"countable enriched Lawvere theories freely generated by $\dots$ operations and equations".
\cite{plotkin2004computational}
"In mathematical practice Lawvere theories arise
whenever one has a functor into a category with finite products
and one studies the natural transformations between finite products of the functor".
\cite{hyland2007category}
A more in-depth mathematical background of Lawvere theories is,
regrettably, beyond the scope of this document.

Returning to the issue of effects,
the essential difference between monads and algebraic effects is that
where monads have a constructed object $TX$,
i.e. the computations of the type $X$,
algebraic effects have operations from which effects arise;
and thus $TX$ is derived not constructed.
Consider the monad $IO Int$ which is the object of computations
of the type $Int$;
from an algebraic effect perspective
one has the operation \texttt{print} which generates the effect
An example of the Lawvere Theory $L_{I/O}$ for input/output
is \textit{generated} by the operations
\begin{equation}
    read : I \rightarrow 1 \quad\textrm{and}\quad write : 1 \rightarrow O
\end{equation}
where $I$ is a countable set of inputs and $O$ of outputs.
\cite{plotkin2001adequacy}

We must also state that
a Lawvere theory is generated by operations subject to equations.

Whilst we have covered operations we have not covered
equations

whilst
operations appear directly in describing programming languages
equations do not.
One of the equations for side-effects is
\begin{equation}
    updateloc,\ v (updateloc,v\prime (x)) = updateloc,v\prime (x)
\end{equation}
and the corresponding program assertion is
\begin{equation}
    (l := x;\ let\ y\ be\ !l\ in\ M) = (l\ := x;\ M[x/y])
\end{equation}
This example is from \cite{plotkin2001adequacy}.

"a class of theories that can be viewed as categories with a monad,
so that
any category with a monad is, up to equivalence (of categories with a monad), one of such theories.
Such a reformulation in terms of theories is more suitable for formal manipulation and more appealing to those unfamiliar with Category Theory."
\cite{moggi1991notions}

The Lawvere theory LE for exceptions is the free Lawvere theory generated by E operations $raise : 0 \rightarrow  1$,
where E is a set of exceptions.
In terms of operations and equations,
this corresponds to an E-indexed family of nullary operations with no equations.
%The monad on Set generated by LE is TE = − + E. More generally, the forgetful functor UL : Mod(LE,C) C induces the monad
%−+E on C, where E is the E-fold copower of 1, i.e.,  exists in C.
It is shown in [39]
that this countable Lawvere theory induces Moggi’s side-effects monad $(S \times \textrm{-})^S$ on
Set.
\cite{hyland2007category}
