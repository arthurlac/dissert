\section{Abridged version}

\subsection{Introduction}
Let's introduce bindables and resumable exceptions

\subsection{Bindables}
Roughly, a bindable is an interface
is something which takes a value
and then allows us to describe ways to chain functions
between bindables of the same type;
even if the things inside them are not of the same type

Bindables are defined by two functions
\begin{align}
    bind &:: B\ x \rightarrow (x \rightarrow List\ y) \rightarrow B\ y\\
    new &:: x \rightarrow B\ x
\end{align}
The way to read is that $::$ means "is of type",
the bind function takes two things,
firstly $B\ x$, which means a bindable of underlying type $x$.
Then $(x \rightarrow B\ y)$ is a function from type $x$,
to the type $B\ y$ which a bindable of type $y$
($y$ could be $x$ but doesn't have to be),
$x$ being the same type as our bindable.
The function returns a bindable of type $y$
You could think of $bind$ as an adapter,

The new function takes any type $x$ and returns
a function bindable of with the underlying type $x$.

Let's give a concrete example!
Foremost example of bindables are lists.

\begin{align}
    bind &:: List\ x \rightarrow (x \rightarrow List\ y) \rightarrow List\ y\\
    new &:: x \rightarrow List\ x
\end{align}

Now implementing $new$ is pretty easy.
\begin{verbatim}
    //Note we use 'unit' as return is a keyword
    const new = x => [x];
    console.log(new(1));
    // === Array [1]
\end{verbatim}

To define bind we gotta define an auxillary function
called join first, it takes a list of lists
and returns a list.
It basically just un-nests the list given.

\begin{verbatim}
    const arr2 = [[1, 2], [3, 4]];
    const append = (onto, val) => onto.concat(val);
    const join = x => x.reduce(append, []);
    console.log(join(arr2));
    // === Array [1, 2, 3, 4]
\end{verbatim}
Once we have done that, defining bind is pretty simple
\begin{verbatim}
    const bind = (x, f) => join(x.map(f));
    const double = x => [x,x];
    console.log(bind(arr1, double));
    // === Array [1, 1, 2, 2, 3, 3, 4, 4]
\end{verbatim}

Let's fix it to lists of integers just to make life ebeginasy
\begin{align}
    bind &:: List\ int \rightarrow (int \rightarrow List\ int) \rightarrow List\ int\\
    new &:: int \rightarrow List\ int
\end{align}

Or in OCaml
\begin{verbatim}
    let fmap f x =
        let rec aux l = match l with
            | [] -> []
            | hd :: tl -> (f hd) :: (aux tl)
        in aux x

    val fmap : ('a -> 'b) -> 'a list -> 'b list

    fmap (fun x -> x + 1) [1;2;3;4];;
    - : int list = [2; 3; 4; 5]
\end{verbatim}
Then we have
\begin{verbatim}
    let return x = [x];;

    val return : 'a -> 'a list

    return 1;;
    - : int list = [1]
\end{verbatim}
Then we have
\begin{verbatim}
    let rec join ll = match ll with
        | [] -> []
        | hd :: tl -> List.append hd (join tl)

    val join : 'a list list -> 'a list

    join [[1;2];[3;4]];;
    - : int list = [1; 2; 3; 4]
\end{verbatim}

Why are bindables so great?
They get rid of stuff like null-pointer exceptions!
They short circuit computations

\begin{verbatim}
    result, err := myFunction()
    if err != nil {
        return nil, err
    }
\end{verbatim}

We should make the distinction that
a monad in haskell $\neq$ a monad in OCaml $\neq$ a monad in category theory
At first this is obvious,
a mathematical construct is obviously different to a programming one,
however it is different between programming languages too,
we have different means to express structures in maths/Haskell/OCaml
thus any non-trivial structure is not really equivalent between these languages.
(maybe obvs but worth considering)
Do programming monads need to follow the same rules as category theory monads?
There is no way for the compiler to check these rules so practically the answer is no,
however it is wise for monad implementations to obey them so that
we can chain computations in predictable and understandable ways.

%For programmers the most important of the triple is \texttt{fmap},
%this is because it is our primary way to interact with the monad.
%Typically we describe our desired result in terms of functions on the monad
%done one after the other.

\subsection{Resumable Exceptions}
For programmers
we are not merely playing with delimited continuations (or resumable exceptions),

For a casual understanding,
we can begin to explain algebraic effects by saying that
we have effects we can manipulate algebraically; that is to say,
the interpretation of an expression is
subject to an operator and its sub-expressions.
For instance, $a + b$ is interpreted as an operator
$+$ with its own semantics along with the value of its
two sub-expressions $a$ and $b$.
As our first example, consider obtaining input from
\texttt{stdin} using the operation \texttt{read} where
\begin{equation}
    read :: \texttt{()} \rightarrow IO\ String
\end{equation}
as a nullary (of zero arguments) operator with no sub-expressions.

We can further our initial understanding with another view
relating algebraic effects to continuations,
or rather algebraic effects being given by continuations.
Whenever an operation is performed we have a continuation
passed to the handler;
which the handler uses to "implement" that effect.
This view also allows us an initial but intuitive
understanding of why algebraic effects are incompatible with continuations;
it is not possible to distribute global control flow across several mechanisms.


\begin{example}
    Consider this example of an IO effect,
    first we define an effect \texttt{IO},
    this is, in OCaml, similar to defining
    a new exception type.
    We then describe two constructors
    \texttt{Print} and \texttt{Read}
    of the effect \texttt{IO}.
    \begin{verbatim}
        effect IO =
          | Print : string -> unit
          | Read : string\end{verbatim}
    Now to actually have an effect we need to use the primitive \texttt{perform},
    we construct an effect via \texttt{(Print "Hello world!")}.
    \begin{verbatim}
        let print_hello =
            perform (Print "Hello world!")\end{verbatim}
    Because OCaml is impure, the handler of this effect looks rather obtuse,
    however in a pure or lazy language this effect and handler would be necessary.
    Here it is just an indirection for the sake of an example.
    \begin{verbatim}
        let () =
          try print_hello with
          | effect (Print s) k -> printf s; continue k\end{verbatim}
\end{example}
\subsection{Conclusion}

A lot of the time bind does exactly what you want,
handlers just force your hand in being explicit
It should be obvious that monads and algebraic effects
are not essential for programming,
or even correct and reliable programming.
However they are really helpful
One can perhaps suggest that pure languages are too dogmatic

"When writing a modular program to solve a problem, one first divides the problem into sub- problems, then solves the sub-problems and combines the solutions. The ways in which one can divide up the original problem depend directly on the ways in which one can glue solutions together. Therefore, to increase ones ability to modularise a problem conceptually, one must provide new kinds of glue in the programming language."
\cite{hughes1989functional}
