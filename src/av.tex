\section{Abridged version}
This document will introduce two concepts,
bindables and resumable exceptions,
will try to show that they are useful
and to an extent equivalent.

\subsection{Bindables}
Roughly, a bindable anything which supports an
interface of two functions $bind$ and $new$.
Bindables are defined by two functions
\begin{align}
    bind &:: B\ x \rightarrow (x \rightarrow List\ y) \rightarrow B\ y\\
    new &:: x \rightarrow B\ x
\end{align}
The way to read is that $::$ means "is of type",
the bind function takes two things,
firstly $B\ x$, which means any bindable of underlying type $x$
where $x$ can be any type you want.
Then it takes $(x \rightarrow B\ y)$ which
is a function taking type $x$,
to the type $B\ y$ which a bindable of type $y$
where $y$ is any type
(and potentially but not necessarily type $x$).
Having been given those two things,
$bind$ returns a bindable of type $y$
You could think of $bind$ as a converter
or adapter between bindables,
even when they are built on different types.

The $new$ function takes any value and
constructs a bindable on top of that value.
Bindables can be built on top of any value,
even a bindable of the same type
or a completely different bindable entirely
(which is of course built on some other value).

Let's give a concrete example,
the easiest and most ubiquitous example of a bindable are lists.

\begin{align}
    bind &:: List\ x \rightarrow (x \rightarrow List\ y) \rightarrow List\ y\\
    new &:: x \rightarrow List\ x
\end{align}

Now implementing $new$ is pretty easy.
\begin{verbatim}
    //Note we use 'unit' as return is a keyword
    const new = x => [x];
    console.log(new(1));
    // === Array [1]
\end{verbatim}

To define bind we gotta define an auxiliary function called join first,
it takes a list of lists and returns a list.
It basically just flattens the list given,
appending each list to the one before it.

\begin{verbatim}
    const arr2 = [[1, 2], [3, 4]];
    const append = (onto, val) => onto.concat(val);
    const join = x => x.reduce(append, []);
    console.log(join(arr2));
    // === Array [1, 2, 3, 4]
\end{verbatim}
Once we have done that, defining bind is pretty simple
\begin{verbatim}
    const bind = (x, f) => join(x.map(f));
    const sqrButKeep = x => [x, x*x];
    console.log(bind([2, -9, 49], sqrButKeep));
    // === Array [2, 4, -9, 81, 49, 2401]
\end{verbatim}

So these examples illustrate what the functions do,
but they are not terribly useful.
Why are bindables so great?
They get rid of null-pointer exceptions!
And exceptions in general.
They cleverly short circuit computations like \texttt{\&\&}.
They can even replace the most common Go idiom:
\begin{verbatim}
    result, err := myFunction()
    if err != nil {
        return nil, err
    }
\end{verbatim}

Let us prove

First we need to introduce the \texttt{letbind} operator in JavaScript

\begin{verbatim}
\end{verbatim}

\subsection{Resumable Exceptions}
A resumable exception is an extension normal exceptions
and exceptions handlers, except we get a continuation to play with.
Given this we can implement async/await

\subsection{Conclusion}

A lot of the time bind does exactly what you want,
handlers just force your hand in being explicit
It should be obvious that monads and algebraic effects
are not essential for programming,
or even correct and reliable programming.
However they are really helpful
One can perhaps suggest that pure languages are too dogmatic

"When writing a modular program to solve a problem, one first divides the problem into sub- problems, then solves the sub-problems and combines the solutions. The ways in which one can divide up the original problem depend directly on the ways in which one can glue solutions together. Therefore, to increase ones ability to modularise a problem conceptually, one must provide new kinds of glue in the programming language."
\cite{hughes1989functional}
