\section{Abridged version}
This document will introduce two concepts,
bindables and resumable exceptions,
will try to show that they are useful
and to an extent equivalent.

\subsection{Bindables}
Roughly, a bindable anything which supports an
interface of two functions $bind$ and $new$.
Bindables are defined by two functions
\begin{align}
    bind &:: B\ x \rightarrow (x \rightarrow List\ y) \rightarrow B\ y\\
    new &:: x \rightarrow B\ x
\end{align}
The way to read is that $::$ means "is of type",
the bind function takes two things,
firstly $B\ x$, which means any bindable of underlying type $x$
where $x$ can be any type you want.
Then it takes $(x \rightarrow B\ y)$ which
is a function taking type $x$,
to the type $B\ y$ which a bindable of type $y$
where $y$ is any type
(and potentially but not necessarily type $x$).
Having been given those two things,
$bind$ returns a bindable of type $y$
You could think of $bind$ as a converter
or adapter between bindables,
even when they are built on different types.

The $new$ function takes any value and
constructs a bindable on top of that value.
Bindables can be built on top of any value,
even a bindable of the same type
or a completely different bindable entirely
(which is of course built on some other value).

Let's give a concrete example,
the easiest and most ubiquitous example of a bindable are lists.

\begin{align}
    bind &:: List\ x \rightarrow (x \rightarrow List\ y) \rightarrow List\ y\\
    new &:: x \rightarrow List\ x
\end{align}

Now implementing $new$ is pretty easy.
\begin{verbatim}
    //Note we use 'unit' as return is a keyword
    const new = x => [x];
    console.log(new(1));
    // === Array [1]
\end{verbatim}

To define bind we gotta define an auxillary function called join first,
it takes a list of lists and returns a list.
It basically just flattens the list given,
appending each list to the one before it.

\begin{verbatim}
    const arr2 = [[1, 2], [3, 4]];
    const append = (onto, val) => onto.concat(val);
    const join = x => x.reduce(append, []);
    console.log(join(arr2));
    // === Array [1, 2, 3, 4]
\end{verbatim}
Once we have done that, defining bind is pretty simple
\begin{verbatim}
    const bind = (x, f) => join(x.map(f));
    const sqrtButKeep = x => [x, x*x];
    console.log(bind([2, 9, 49], double));
    // === Array [2, 4, 9, 81, 49, 2401]
\end{verbatim}

So these examples illustrate what the functions do,
but they are not terribly useful.
Why are bindables so great?
They get rid of null-pointer exceptions!
And exceptions in general.
They cleverly short circuit computations like \texttt{\&\&}.
They can even replace the most common Go idiom:
\begin{verbatim}
    result, err := myFunction()
    if err != nil {
        return nil, err
    }
\end{verbatim}

Let us prove

\subsection{Resumable Exceptions}
A resumable exception is an extension of
exceptions in 
For programmers
we are not merely playing with delimited continuations (or resumable exceptions),

For a casual understanding,
we can begin to explain algebraic effects by saying that
we have effects we can manipulate algebraically; that is to say,
the interpretation of an expression is
subject to an operator and its sub-expressions.
For instance, $a + b$ is interpreted as an operator
$+$ with its own semantics along with the value of its
two sub-expressions $a$ and $b$.
As our first example, consider obtaining input from
\texttt{stdin} using the operation \texttt{read} where
\begin{equation}
    read :: \texttt{()} \rightarrow IO\ String
\end{equation}
as a nullary (of zero arguments) operator with no sub-expressions.

We can further our initial understanding with another view
relating algebraic effects to continuations,
or rather algebraic effects being given by continuations.
Whenever an operation is performed we have a continuation
passed to the handler;
which the handler uses to "implement" that effect.
This view also allows us an initial but intuitive
understanding of why algebraic effects are incompatible with continuations;
it is not possible to distribute global control flow across several mechanisms.


\begin{example}
    Consider this example of an IO effect,
    first we define an effect \texttt{IO},
    this is, in OCaml, similar to defining
    a new exception type.
    We then describe two constructors
    \texttt{Print} and \texttt{Read}
    of the effect \texttt{IO}.
    \begin{verbatim}
        effect IO =
          | Print : string -> unit
          | Read : string\end{verbatim}
    Now to actually have an effect we need to use the primitive \texttt{perform},
    we construct an effect via \texttt{(Print "Hello world!")}.
    \begin{verbatim}
        let print_hello =
            perform (Print "Hello world!")\end{verbatim}
    Because OCaml is impure, the handler of this effect looks rather obtuse,
    however in a pure or lazy language this effect and handler would be necessary.
    Here it is just an indirection for the sake of an example.
    \begin{verbatim}
        let () =
          try print_hello with
          | effect (Print s) k -> printf s; continue k\end{verbatim}
\end{example}
\subsection{Conclusion}

A lot of the time bind does exactly what you want,
handlers just force your hand in being explicit
It should be obvious that monads and algebraic effects
are not essential for programming,
or even correct and reliable programming.
However they are really helpful
One can perhaps suggest that pure languages are too dogmatic

"When writing a modular program to solve a problem, one first divides the problem into sub- problems, then solves the sub-problems and combines the solutions. The ways in which one can divide up the original problem depend directly on the ways in which one can glue solutions together. Therefore, to increase ones ability to modularise a problem conceptually, one must provide new kinds of glue in the programming language."
\cite{hughes1989functional}
