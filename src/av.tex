\section{Abridged version}

\subsection{Introduction}
Not only do they share a history, finitary monads and Lawvere theories
"describe equivalent categorical encodings of universal algebra"\cite{riehl}.
These ideas, while fascinating and perplexing,
are not central to this document;
we discuss them in this overview for an additional,
although brief, perspective.

\subsection{Monads}
The easiest way to begin understanding monads is by thinking of them
as a triple of functions with the interface
\begin{equation}
  \begin{split}
    map  &:: (x \rightarrow y) \rightarrow M x \rightarrow M y \\
    unit &:: x \rightarrow M x                                 \\
    join &:: M (M x) \rightarrow M x
  \end{split}
\end{equation}
where $M$ is the monad. The most ubiquitous monad is the list monad
so let's give a concrete interface where we have list of integers
\begin{equation}
  \begin{split}
    map  &:: (int \rightarrow int) \rightarrow List int \rightarrow List int \\
    unit &:: int \rightarrow List int                                        \\
    join &:: List (List int) \rightarrow List int
  \end{split}
\end{equation}

However we can create a new function from this triple
\begin{align}
    bind &:: M x \rightarrow (x \rightarrow M y) \rightarrow M y \\
    bind &\equiv \lambda mx. \lambda f. join(fmap\ f\ mx)
\end{align}
Bind is incredibly useful and perhaps more prominent to a programmer than the triple $(fmap,return,join)$.
This is because it allows us to chain computations
one after the other.
\begin{equation}
    x\
    \stackrel{f}{\rightarrow} My
    \stackrel{g}{\rightarrow} MMz
    \stackrel{join}{\rightarrow} Mz
\end{equation}
\begin{equation}
    \lambda g.
    \lambda f.
    \lambda x.
    join\ (fmap\ g\ (fmap\ f\ x))
\end{equation}
\begin{equation}
    (fmap\ f\ x) >>= g
\end{equation}

It is convention to use bind as the infix operator "$\bind$".
Because \texttt{bind} is often found with \texttt{(fmap,join,return)}
We can reformulate our axioms in terms of bind,
indeed the axioms are often reformulated this way because it is simpler.
\begin{align}
    return\ x \bind f &\equiv f x \\
    m \bind return &\equiv m \\
    (m \bind f) \bind g &\equiv m \bind (\lambda x.(f\ x \bind g))
\end{align}

We should make the distinction that
a monad in haskell $\neq$ a monad in OCaml $\neq$ a monad in category theory
At first this is obvious,
a mathematical construct is obviously different to a programming one,
however it is different inbetween programming languages too,
we have different means to express structures in maths/Haskell/OCaml
thus any non-trivial structure is not really equivalent between these languages.
(maybe obvs but worth considering)

A concrete example of fmap/bind/join expressed in JavaScript or ECMAScript is
\begin{verbatim}
    const arr = [1,2,3,4];
    const fmap = (f,x) => x.map(f); //Easy in JS for arrays
    console.log(fmap(x => x + 1, arr));
    // === Array [2,3,4,5]

    //Note we use 'unit' as return is a keyword
    const unit = x => [x];
    console.log(unit(1));
    // === Array [1]

    const arr2 = [[1, 2], [3, 4]];
    const append = (onto, val) => onto.concat(val);
    const join = x => x.reduce(append, []);
    console.log(join(arr2));
    // === Array [1, 2, 3, 4]

    const bind = (x, f) => join(fmap(f,x));
    const double = x => [x,x];
    console.log(bind(arr1, double));
    // === Array [1, 1, 2, 2, 3, 3, 4, 4]
\end{verbatim}


Or in OCaml
\begin{verbatim}
    let fmap f x =
        let rec aux l = match l with
            | [] -> []
            | hd :: tl -> (f hd) :: (aux tl)
        in aux x

    val fmap : ('a -> 'b) -> 'a list -> 'b list

    fmap (fun x -> x + 1) [1;2;3;4];;
    - : int list = [2; 3; 4; 5]
\end{verbatim}
Then we have
\begin{verbatim}
    let return x = [x];;

    val return : 'a -> 'a list

    return 1;;
    - : int list = [1]
\end{verbatim}
Then we have
\begin{verbatim}
    let rec join ll = match ll with
        | [] -> []
        | hd :: tl -> List.append hd (join tl)

    val join : 'a list list -> 'a list

    join [[1;2];[3;4]];;
    - : int list = [1; 2; 3; 4]
\end{verbatim}


\begin{verbatim}
    result, err := myFunction()
    if err != nil {
        return nil, err
    }
\end{verbatim}

Do programming monads need to follow the same rules as category theory monads?
There is no way for the compiler to check these rules so practically the answer is no,
however it is wise for monad implementations to obey them so that
we can chain computations in predictable and understandable ways.

%For programmers the most important of the triple is \texttt{fmap},
%this is because it is our primary way to interact with the monad.
%Typically we describe our desired result in terms of functions on the monad
%done one after the other.

\subsection{Algebraic Efffects}
For programmers
we are not merely playing with delimited continuations (or resumable exceptions),

