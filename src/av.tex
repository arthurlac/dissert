\section{Abridged version}

\subsection{Introduction}
Not only do they share a history, finitary monads and Lawvere theories
"describe equivalent categorical encodings of universal algebra"\cite{riehl}.
These ideas, while fascinating and perplexing,
are not central to this document;
we discuss them in this overview for an additional,
although brief, perspective.

\subsection{Monads}
The easiest way to begin understanding monads is by thinking of them
as a triple of functions with the interface
\begin{equation}
  \begin{split}
    map  &:: (x \rightarrow y) \rightarrow M x \rightarrow M y \\
    unit &:: x \rightarrow M x                                 \\
    join &:: M (M x) \rightarrow M x
  \end{split}
\end{equation}
where $M$ is the monad. The most ubiquitous monad is the list monad
so let's give a concrete interface where we have list of integers
\begin{equation}
  \begin{split}
    map  &:: (int \rightarrow int) \rightarrow List\ int \rightarrow List\ int \\
    unit &:: int \rightarrow List\ int                                        \\
    join &:: List\ (List\ int) \rightarrow List\ int
  \end{split}
\end{equation}

However we can create a new function from this triple
\begin{align}
    bind &:: M x \rightarrow (x \rightarrow M y) \rightarrow M y \\
    bind &\equiv \lambda mx. \lambda f. join(fmap\ f\ mx)
\end{align}
Bind is incredibly useful and perhaps more prominent to a programmer than the triple $(fmap,return,join)$.
This is because it allows us to chain computations
one after the other.
\begin{equation}
    x\
    \stackrel{f}{\rightarrow} My
    \stackrel{g}{\rightarrow} MMz
    \stackrel{join}{\rightarrow} Mz
\end{equation}
\begin{equation}
    \lambda g.
    \lambda f.
    \lambda x.
    join\ (fmap\ g\ (fmap\ f\ x))
\end{equation}
\begin{equation}
    (fmap\ f\ x) >>= g
\end{equation}

It is convention to use bind as the infix operator "$\bind$".
Because \texttt{bind} is often found with \texttt{(fmap,join,return)}
We can reformulate our axioms in terms of bind,
indeed the axioms are often reformulated this way because it is simpler.
\begin{align}
    return\ x \bind f &\equiv f x \\
    m \bind return &\equiv m \\
    (m \bind f) \bind g &\equiv m \bind (\lambda x.(f\ x \bind g))
\end{align}

We should make the distinction that
a monad in haskell $\neq$ a monad in OCaml $\neq$ a monad in category theory
At first this is obvious,
a mathematical construct is obviously different to a programming one,
however it is different inbetween programming languages too,
we have different means to express structures in maths/Haskell/OCaml
thus any non-trivial structure is not really equivalent between these languages.
(maybe obvs but worth considering)

A concrete example of fmap/bind/join expressed in JavaScript or ECMAScript is
\begin{verbatim}
    const arr = [1,2,3,4];
    const fmap = (f,x) => x.map(f); //Easy in JS for arrays
    console.log(fmap(x => x + 1, arr));
    // === Array [2,3,4,5]

    //Note we use 'unit' as return is a keyword
    const unit = x => [x];
    console.log(unit(1));
    // === Array [1]

    const arr2 = [[1, 2], [3, 4]];
    const append = (onto, val) => onto.concat(val);
    const join = x => x.reduce(append, []);
    console.log(join(arr2));
    // === Array [1, 2, 3, 4]

    const bind = (x, f) => join(fmap(f,x));
    const double = x => [x,x];
    console.log(bind(arr1, double));
    // === Array [1, 1, 2, 2, 3, 3, 4, 4]
\end{verbatim}


Or in OCaml
\begin{verbatim}
    let fmap f x =
        let rec aux l = match l with
            | [] -> []
            | hd :: tl -> (f hd) :: (aux tl)
        in aux x

    val fmap : ('a -> 'b) -> 'a list -> 'b list

    fmap (fun x -> x + 1) [1;2;3;4];;
    - : int list = [2; 3; 4; 5]
\end{verbatim}
Then we have
\begin{verbatim}
    let return x = [x];;

    val return : 'a -> 'a list

    return 1;;
    - : int list = [1]
\end{verbatim}
Then we have
\begin{verbatim}
    let rec join ll = match ll with
        | [] -> []
        | hd :: tl -> List.append hd (join tl)

    val join : 'a list list -> 'a list

    join [[1;2];[3;4]];;
    - : int list = [1; 2; 3; 4]
\end{verbatim}


\begin{verbatim}
    result, err := myFunction()
    if err != nil {
        return nil, err
    }
\end{verbatim}

Do programming monads need to follow the same rules as category theory monads?
There is no way for the compiler to check these rules so practically the answer is no,
however it is wise for monad implementations to obey them so that
we can chain computations in predictable and understandable ways.

%For programmers the most important of the triple is \texttt{fmap},
%this is because it is our primary way to interact with the monad.
%Typically we describe our desired result in terms of functions on the monad
%done one after the other.

\subsection{Algebraic Efffects}
For programmers
we are not merely playing with delimited continuations (or resumable exceptions),

For a casual understanding,
we can begin to explain algebraic effects by saying that
we have effects we can manipulate algebraically; that is to say,
the interpretation of an expression is
subject to an operator and its sub-expressions.
For instance, $a + b$ is interpreted as an operator
$+$ with its own semantics along with the value of its
two sub-expressions $a$ and $b$.
As our first example, consider obtaining input from
\texttt{stdin} using the operation \texttt{read} where
\begin{equation}
    read :: \texttt{()} \rightarrow IO\ String
\end{equation}
as a nullary (of zero arguments) operator with no sub-expressions.

We can further our initial understanding with another view
relating algebraic effects to continuations,
or rather algebraic effects being given by continuations.
Whenever an operation is performed we have a continuation
passed to the handler;
which the handler uses to "implement" that effect.
This view also allows us an initial but intuitive
understanding of why algebraic effects are incompatible with continuations;
it is not possible to distribute global control flow across several mechanisms.


\begin{example}
    Consider this example of an IO effect,
    first we define an effect \texttt{IO},
    this is, in OCaml, similar to defining
    a new exception type.
    We then describe two constructors
    \texttt{Print} and \texttt{Read}
    of the effect \texttt{IO}.
    \begin{verbatim}
        effect IO =
          | Print : string -> unit
          | Read : string\end{verbatim}
    Now to actually have an effect we need to use the primitive \texttt{perform},
    we construct an effect via \texttt{(Print "Hello world!")}.
    \begin{verbatim}
        let print_hello =
            perform (Print "Hello world!")\end{verbatim}
    Because OCaml is impure, the handler of this effect looks rather obtuse,
    however in a pure or lazy language this effect and handler would be necessary.
    Here it is just an indirection for the sake of an example.
    \begin{verbatim}
        let () =
          try print_hello with
          | effect (Print s) k -> printf s; continue k\end{verbatim}
\end{example}
\subsection{Conclusion}

A lot of the time bind does exactly what you want,
handlers just force your hand in being explicit
It should be obvious that monads and algebraic effects
are not essential for programming,
or even correct and reliable programming.
However they are really helpful
One can perhaps suggest that pure languages are too dogmatic

