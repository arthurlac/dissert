\section{Algebraic Effects}
Algebraic effects, like monads, can be used to model effects in a pure language.
As discussed previously,
Following from our discussion of Lawvere theories,
we will now explore their programming language progeny \textit{algebraic effects}.
The essence is
we have operations which generate effects,

Next key point is handlers
to actually interact with them as programming constructs algebraic effects are paired with
handlers \cite{plotkin2009handlers}.


We can begin to understand algebraic effects by saying that
we have effects we can manipulate algebraically;
that is

    subject to purely local rewrites, or, alternately,
    in such a way that the interpretation of an expression
    can be given as an operator on the interpretation of its subexpressions."

We can further our initial understanding with another view
relating algebraic effects to continuations,
or rather algebraic effects being given by continuations.
Whenever an operation is performed we have a continuation
passed to the handler;
which the handler uses to "implement" that effect.
This view also allows us an initial but intuitive
understanding of why algebraic effects are incompatible with continuations,
it is not possible to distribute global control flow across
several mechanisms.




Change of viewpoint:
we are not merely playing with delimited continuations (or resumable exceptions),
we are defining side-effects.
(Side-effects implemented through control; “the mother of all monads”)
Claim: this is more structured, makes code easier to understand.
Nota Bene: we can provide different handlers for the same signature."

To the programmer perhaps the most interesting implication
is that we can now have programmer defined effects,
specifying multiple handlers for an effect

previously effects were completely implicit
now they are under direct explicit control of the programmer


Currently algebraic effects are a popular area of research,
and may well enter the mainstream in the next decade;
potentially because imperative programmers
will find them more intuitive equivalent monads.
Algebraic effects represent the cutting edge of effect management
in programming languages as such we have seen
a multitude of implementations in recent years

\textbf{Some Algebraic Effect Implementations}
\begin{itemize}
    \item Eff: Matija Pretnar and Andrej Bauer,
        2015\cite{bauer2015programming}
    \item Frank: Sam Lindley and Conor McBride
        2016\cite{Lindley:2016vz}
    \item OCaml+effects: Stephen Dolan, Leo White, KC Sivaramakrishnan,
        2016\cite{ocamlplseff}
    \item Koka: Dan Leijen
        2016\cite{leijen:16}
\end{itemize}

\subsection{Overview}

\begin{example}
    Consider the examples of effects we gave at the beginning of this document.
    Each of these effects has a natural operation which generates the effect.
    Consider
    \begin{itemize}
        \item Input/Output \textit{generated by} \texttt{read, write}
        \item Mutable state \textit{generated by} \texttt{set, get}
        \item Exceptions \textit{generated by} \texttt{raise}
        \item Non-Determinism \textit{generated by the binary} \texttt{choose}
        \item Probabilistic Non-Determinism \textit{generated by} \texttt{random choice}
    \end{itemize}
\end{example}

Notice that we have not mentioned continuations here,
this is because
"continuations are computationally of a different character to other computational effects"
\cite{Plotkin:2002dw}.

"There are computationally natural families of operations associated with several of the above monads:
An analysis of several of thesefamiliesofoperationsappearsin[20]:
theyareregardedasalgebraicfami- lies of operations associated with an already given monad,
and are characterised intermsofgenericeffects:e.g.,
togiveagenericeffecte:nTmisequivalent togivingmn-aryalgebraicfamiliesofoperations,
wheremandnneednotbe finite(misthem-foldcoproductof1inC).
Cruciallywhenamonadisgiven byalgebraicoperationsandequationsinthesenseof,
thealgebraicfamilies of operations associated with it are given by the derived operations."
\cite{Plotkin:2002dw}

\begin{example}
    Consider this example of an IO effect,
    first we define an effect \texttt{IO}
    and then describe two constructors
    \texttt{Print} and \texttt{Read}.
    To actually have an effect we use the primitive
    perform on an effect we construct, in this case with \texttt{Print}.
    \begin{verbatim}
        effect IO =
          | Print : string -> unit
          | Read : string

        perform (Print "Hello world");
    \end{verbatim}
\end{example}


The core benefits of algebraic effects are
firstly composition and secondly 
allowing the programmer to separate the expression of an effectful computation from its implementation."
They "provide a modular abstraction for expressing effectful computation"\cite{dolan2015effective},
\cite{dolan2015effective}
This is a benefit we saw with monads,
seperating the happy path from our error handling

It would appear that algebraic effects are particularly popular
for systems programming
\cite{dolan2015effective}
\cite{dolan2017concurrent}
\cite{dolaneffectively}
\cite{Dolan:2017}
we will try to elucidate why this,
especially in comparison to monads
It would appear that the OCaml+effects implementation
will be algebraic effects first "prime time" appearance
and will be incredibly important for the OCaml language in the future.

"In this paper, we make the observation that effect handlers can elegantly express particularly difficult programs that combine system programming and concurrency without compromising performance. "
\cite{Dolan:2017}

\subsection{Handlers}
Thus far we have only
where operations are constructors of effects
we also need a dual,
\textit{handlers} which can be seen as deconstructors of effects
\cite{}.
Handlers were introduced by Plotkin and Pretner\cite{Plotkin:2009dr}
builds on
\cite{benton2001exceptional}
.

"Of the various operations, handle is of a different computational character and, although natural, it is not algebraic
Andrzej Filinski (personal communication) describes handle as a deconstructor, whereas the other operations are constructors (of effects). In this paper, we make the notion of constructor precise by identifying it with the notion of algebraic operation."
\cite{Plotkin:2002dw}

"present an algebraic treatment of exception handlers and,
more generally, introduce handlers for other computational effects
representable by an algebraic theory"
"Although the algebraic approach has given ways of constructing,
combining, and reasoning about effects, it has not yet accounted for their handling.


The difficulty is that exception handlers, a well-known programming concept,
fail to be algebraic operations.

Conceptually, algebraic operations and effect handlers are dual:
the former could be called effect constructors as they give rise to the effects;
the latter could be called effect deconstructors as they depend on the effects already created.

Filinski’s reflection and reification operations provide general effect constructors
and deconstructors in the context of layered monads [5]."

"The central new semantic idea is that deconstructing a computation amounts to
applying to it a unique homomorphism guaranteed by universality.
The domain of this homomorphism is a free model of the algebraic theory of the effects at hand;
its range is a programmer-defined model of the algebraic theory;
and it extends a programmer-defined map on values."
\cite{Plotkin:2009dr}


new handling construct generalises the exception-handling construct of Benton and Kennedy. \cite{benton2001exceptional}


"Plotkin and Pretnar’s handlers for algebraic effects occupy a sweet spot in the design space of abstractions for effectful computation. By separating effect signatures from their implementation, alge- braic effects provide a high degree of modularity, allowing pro- grammers to express effectful programs independently of the con- crete interpretation of their effects. A handler is an interpretation of the effects of an algebraic computation. The handler abstraction adapts well to multiple settings: pure or impure, strict or lazy, static types or dynamic types."
\cite{kammar2013handlers}

A key benefit of handlers, and hence of algebraic effects,
is that

and there is a natural separation between
their interface (as a set of operations)
and
their semantics (as a handler)."
"the signature of the effect operations forms a free algebra which gives rise to a free monad.
Free monads provide a natural way to give semantics to effects,
where handlers describe a fold over the algebra of operations.
Using a more operational perspective,
we can also view algebraic effects as resumable exceptions
(or perhaps as a more structured form of delimited continuations)."
\cite{leijen2017type}

\subsection{Composing Algebraic Effects}
What has become the most evident deficiency of monads is
how difficult and tricky it is to compose them.
Composability is often touted as one the most
prominent advantages of functional programming
Fortunately composing algebraic effects is much more simple than composing monads.

How to compose algebraic effects?
\begin{example}
    \begin{verbatim}
    effect IO =
  | Print : string -> unit
  | Read : string

    effect choice =
  | Choose : bool

    effect int_state =
  | Get : int
  | Set : int -> unit

    let incr_maybe_twice () : int =
  perform (Set ((perform Get) + 1));
  if (perform Choose)
  then perform (Set ((perform Get) + 1))
  else perform (Print "incremented just once");
  perform Get
    \end{verbatim}

    \begin{verbatim}
    module State (S : sig type t end) with type t = S.t = struct

  type t = S.t

  effect Put : t -> unit
  let put v = perform (Put v)

  effect Get : t
  let get () = perform Get

  let run f ~init =
    let comp =
      match f () with
      | x -> (fun s -> (s, x))
      | effect (Put s') k -> (fun s -> continue k () s')
      | effect Get k -> (fun s -> continue k s s)
    in comp init
    end
    module IS = State (struct type t = int end)
    module SS = State (struct type t = string end)

    let foo () : unit =
  printf "%d\n" (IS.get ());
  IS.put 42;
  printf "%d\n" (IS.get ());
  IS.put 21;
  printf "%d\n" (IS.get ());
  SS.put "hello";
  printf "%s\n" (SS.get ());
  SS.put "world";
  printf "%s\n" (SS.get ())

    let _ = IS.run (fun () -> SS.run foo "") 0
    \end{verbatim}
\end{example}

A potential advantage of algebraic effects over monads is that
the "
notion of countable enriched Lawvere theory
provides us with a natural way to describe
how computational effects may be combined.
"
\cite{plotkin2004computational}.
I.e. algebraic effects compose more naturally.

"Monad transformers [25] provide a form of modular instantia- tion for abstract monadic computations. For instance, state can be handled in the presence of other effects by incorporating a state monad transformer within a monad transformer stack.
A fundamental problem with monad transformer stacks is that once a particular abstract effect is instantiated, the order of effects in the stack becomes concrete, and it becomes necessary to explic- itly lift operations through the stack. Taming the monad transformer stack is an active research area [16, 17, 38, 42]."
\cite{kammar2013handlers}


\subsection{Structuring Programs with Algebraic Effects}
Monad transformers can quickly become unwieldy when there are lots of effects to manage,
leading to a temptation in larger programs to combine everything into one coarse-grained state and exception monad.
[Programming and Reasoning with Algebraic Effects and Dependent Types]

As we demonstrated monads are rather useful for structuring programs,
allowing us to only consider the happy path while remaining assured
edge cases are handled;
it is natural to ask if programming with algebraic effects
has the same properties?

Recall our implementation of a trie with monads,
we will now explore whether an algebraic effect implementation
\begin{verbatim}
  let get t key =
    let rec search chars t =
        match chars with
        | []      -> val_extract t
        | c :: cs -> bind_search (find_child t c) cs
    and bind_search ot chars = ot >>= search chars
    in search key t
\end{verbatim}

Contrast this with an algebraic effect implementation

\begin{verbatim}
  effect raise


  let get t key =
    let rec search chars t =
        match chars with
        | []      -> val_extract t
        | c :: cs -> bind_search (find_child t c) cs
    and bind_search ot chars = ot >>= search chars
    in search key t

\end{verbatim}

We can 

\begin{verbatim}
    get :: m s
    get = state (\s -> (s, s))
    put :: s -> m ()
    put s = state (\_ -> ((), s))
    state :: (s -> (a, s)) -> m a
    state f = do
      s <- get
      let ~(a, s') = f s
      put s'
      return a
\end{verbatim}

\subsection{Comparison with Monads}
lots of ppl say the monads when composed make effects coarse grained
and this is ugly

OCaml is impure but has monads, and soon effects, wen you need them?
is this the most 'pratical' approach?

algebraic effects are more scalable solution for engineering programs!

this maybe one of the reasons why they seem to be so popular in systems
programming

