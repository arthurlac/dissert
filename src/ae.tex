\section{Algebraic Effects}
Following from our discussion of Lawvere theories,
we will now explore their programming language progeny \textit{algebraic effects}.
The essence is we have \textit{operations} which generate effects,
and to actually interact with them as programming constructs
we need \textit{handlers}\cite{plotkin2009handlers};
which, informally, deconstruct effects.
This section will cover these two issues and their use.

For a casual understanding,
we can begin to explain algebraic effects by saying that
we have effects we can manipulate algebraically; that is to say,
the interpretation of an expression is
subject to an operator and its sub-expressions.
For instance, $a + b$ is interpreted as an operator
$+$ with its own semantics along with the value of its
two sub-expressions $a$ and $b$.
As our first example, consider the maybe monad where we have
\texttt{Nothing | Just x},
this monad is generated by
\begin{equation}
    raise :: 0 \rightarrow 1
\end{equation}
a nullary (of zero arguments) operator with no sub-expressions.

We can further our initial understanding with another view
relating algebraic effects to continuations,
or rather algebraic effects being given by continuations.
Whenever an operation is performed we have a continuation
passed to the handler;
which the handler uses to "implement" that effect.
This view also allows us an initial but intuitive
understanding as to why algebraic effects are incompatible with continuations;
it is not possible to distribute global control flow across several mechanisms.

However algebraic effects are not simply just continuations,
they are programmer defined effects.
To a programmer, this is perhaps the most interesting implication,
we can now have programmer defined effects.
Moreover potentially specifying multiple handlers for each effect.
The lack of control programmers had over effects plays
a large reason in why they are a source of many bugs,
now they are under direct and explicit control of the programmer.

Currently algebraic effects are a popular area of research,
they represent the cutting edge of programming language design,
as such we have seen a multitude of implementations in recent years.
They may well enter the mainstream (as mainstream as monads at least)
due to multicore OCaml being implemented in terms of algebraic effects.
Additionally, it is likely that imperative programmers
will find algebraic effects more intuitive than an equivalent monad.

\textbf{Some Algebraic Effect Implementations}
\begin{itemize}
    \item Eff: Matija Pretnar and Andrej Bauer,
        2015\cite{bauer2015programming}
    \item Frank: Sam Lindley and Conor McBride
        2016\cite{Lindley:2016vz}
    \item OCaml+effects: Stephen Dolan, Leo White, KC Sivaramakrishnan,
        2016\cite{ocamlplseff}
    \item Koka: Dan Leijen
        2016\cite{leijen:16}
\end{itemize}

\subsection{Overview}
\begin{example}
    Recall the examples of effects we gave at the beginning of this document,
    each of these effects has a natural operation which generates the effect.
    Consider
    \begin{itemize}
        \item Input/Output \textit{generated by} \texttt{read, write}
        \item Mutable state \textit{generated by} \texttt{set, get}
        \item Exceptions \textit{generated by} \texttt{raise}
        \item Non-Determinism \textit{generated by} \texttt{choose}
        \item Probabilistic Non-Determinism \textit{generated by} \texttt{choice}
    \end{itemize}
\end{example}

Notice that continuations are not mentioned here,
this is because, as discussed previously,
continuations are of a computationally different character
than these other effects
\cite{Plotkin:2002dw}\cite{hyland2007combining}.

Let us examine input and output as an algebraic effect in detail,
we will begin with the quintessential programming example; "Hello world!".
We will be working in OCaml+effects\cite{ocamlplseff} for this example,
basing our code on \cite{kceff}.\\

\begin{example}
    Consider this example of an IO effect,
    first we define an effect \texttt{IO},
    this is, in OCaml, similar to defining
    a new exception type.
    We then describe two constructors
    \texttt{Print} and \texttt{Read}
    of the effect \texttt{IO}.
    \begin{verbatim}
        effect IO =
          | Print : string -> unit
          | Read : string\end{verbatim}
    Now to actually have an effect we need to use the primitive \texttt{perform},
    we construct an effect via \texttt{(Print "Hello world!")}.
    \begin{verbatim}
        let print_hello () =
            perform (Print "Hello world!")\end{verbatim}
    Because OCaml is impure, the handler of this effect looks rather obtuse,
    however in a pure or lazy language this effect and handler would be necessary.
    Here it is just an indirection for the sake of an example.
    \begin{verbatim}
        let main () =
          try print_hello () with
          | effect (Print s) k -> printf s; continue k\end{verbatim}
\end{example}

\subsection{Handlers}
Thus far we have only examined how to perform effects,
we need a mechanism by which to give these operations semantics.
Where operations are constructors of effects we also need a dual, \textit{handlers}.
They can be seen as deconstructors of effects\cite{Plotkin:2002dw}.

Handlers were introduced by Plotkin and Pretner\cite{Plotkin:2009dr},
the new handling construct generalises the exception-handling
construct of Benton and Kennedy\cite{benton2001exceptional}.
The key difference between typical exception handlers
and algebraic effect handlers is that
there is a continuation allowing for arbitrary effects to be expressed.

Handlers present one of the greatest benefits of algebraic effects;
"by separating effect signatures from their implementation,
algebraic effects provide a high degree of modularity"\cite{kammar2013handlers}.
Modularity is always important when engineering software
and allowing programmers to create an interface between
the expression of an effectful computation
and the concrete interpretation of their effects.

\subsection{Composing Algebraic Effects}
What has become the most evident deficiency of monads is
how difficult and tricky it is to compose them.
This is particularly unpleasant as
composability is often touted as one the most practical advantages of functional programming.
Fortunately composing algebraic effects is much less complicated than composing monads!
There exists an intuitive way to compose algebraic effects,
for example one doesn't need to consider order of composition as one does with monads.
This advantage stems from the theory in fact,
the "notion of countable enriched Lawvere theory
provides us with a natural way to describe
how computational effects may be combined
"\cite{plotkin2004computational}.\\

\begin{example}
Another example of algebraic effects is binary non-determinism,
here we simulate a coin flip.
\begin{verbatim}
    effect choice = Choose : bool

    type coin = Heads | Tails

    let coin_flip () : coin =
        if (perform Choose) then
            Heads
        else
            Tails

    try coin_flip () with
    | effect Choose k -> continue k (Random.bool ())
    \end{verbatim}
\end{example}
Now let us tackle the question of how to actually compose
algebraic effects.\\

\begin{example}
    Recall our IO and non-determinism examples,
    we can combine them with ease!
\begin{verbatim}
effect IO =
| Print : string -> unit
| Read : string

effect choice =
| Choose : bool

effect int_state =
| Get : int
| Set : int -> unit
\end{verbatim}
    We will attempt to combine these three effects.
    Firstly we begin by defining a handler for
    our stateful effects.
\begin{verbatim}
let run_state f ~init =
  let comp =
    match f () with
    | x -> (fun s -> (s, x))
    | effect (Put s') k -> (fun s -> continue k () s')
    | effect Get k -> (fun s -> continue k s s)
  in comp init
\end{verbatim}
We can run a stateful computation by calling this function as such
\begin{verbatim}
let incr_twice () : int =
  perform (Set ((perform Get) + 1));
  perform (Set ((perform Get) + 1));
  perform (Get)

run_state incr_twice ~init:0 (* = 2 *)
\end{verbatim}
We can combine this with non-determinism
rather simply and elegantly.
\begin{verbatim}
let maybe_incr () : int =
  if (perform Choose) then perform (Set ((perform Get) + 2);
  perform (Get)

match run_state maybe_incr_twice ~init:0 with
| effect (Choose) k -> coninute k (Random.bool ())
\end{verbatim}
\end{example}

This is rather pleasant compared to
an equivalent monad transformer stack.
One can isolate which effects one wants to
deal with at a function level,
and one does not end up with a global
coarse grained effect at the top level
of the program.

\subsection{Structuring Programs with Algebraic Effects}
As we demonstrated monads are rather useful for structuring programs,
for example,
allowing us to only consider the happy path while remaining assured
edge cases are handled;
it is natural to ask if programming with algebraic effects
has the same properties?

Recall our implementation of a trie with monads,
we will now explore whether an algebraic effect implementation
\begin{verbatim}
  let get t key =
    let rec search chars t =
        match chars with
        | []      -> val_extract t
        | c :: cs -> bind_search (find_child t c) cs
    and bind_search ot chars = ot >>= search chars
    in search key t
\end{verbatim}

Contrast this with an algebraic effect implementation
\begin{verbatim}
  effect exception = Exn

  let get t key =
    let rec search chars t =
        match chars with
        | []      -> val_extract t
        | c :: cs -> search_children t c cs
    and search_children t c chars =
        match find_child t c with
        | None -> perform Exn
        | Some -> search chars
    in try search key t with
    | effect Exn _ -> None
    | value -> value
\end{verbatim}

We can immediately see that this implementation is more verbose,
which is not necessarily desirable;
however the mechanisms of how this function works
are more apparent, which in some instances is desirable.
Code which is hard to understand has a high burden.
This code has the benefit of being direct, that said
it comes at the cost of explicit data flow.

Leijen\cite{leijen2017structured} established that
asynchrony, most common in EcmaScript (best known as JavaScript),
can be expressed via algebraic effects.
Previously expressing asynchrony via callbacks
lead to programs which were difficult to both write and debug,
leading to the notion of the “pyramid of doom” or
"callback-hell" when code was poorly structured.
Async await syntax has been found as solution
however asynchrony is well expressed through algebraic effects,
perhaps it is worth reflecting on an alternate world
were JS went with algebraic effects.

This is typically how one might see an asynchronous
computation in JS:
\begin{verbatim}
function resolveAfter2Seconds() {
  return new Promise(resolve => {
    setTimeout(() => {
      resolve('resolved');
    }, 2000);
  });
}

async function asyncCall() {
  console.log('calling');
  var result = await resolveAfter2Seconds();
  console.log(result);
  // expected output: "resolved"
}
\end{verbatim}
Compare this with a psuedo JavaScript example for algebraic effects
(which also incorporates a proposal for pattern matching \cite{jspmatch}).
\begin{verbatim}
function algebraicEffectCall() {
    let tries = 0;
    let asyncCall = () = try {
        perform(new Promise(resolve => {
            setTimeout(() => {resolve('resolved'); }, 2000);
        }));
        asynCall();
      ));
    } with (promise) {
      { state: "fulfilled", value: output       } => output,
      { state: "rejected",  value: err,    cont } => {
          console.log(err);
          tries++;
          if tries > 3 {
              return defaultVal;
          } else {
              // Try again
              continue cont;
          }
      }
    }
}
\end{verbatim}
It goes without saying that this example is more verbose than the current state of async/await,
however it is much more expressively powerful.
In this example we implement a retry mechanism and specify a default value return option.
It is also worth noting \texttt{async/await} syntax is the result of several years of
streamlining and programming language design,
as such it is expected to be much more polished.

\subsection{Conclusion}
There are two core benefits of algebraic effects.
Firstly, composition of algebraic effects is simple and pain free.
Secondly they allow a seperation between
"the expression of an effectful computation from its implementation"
\cite{dolan2015effective}.
This is a powerful tool of modular abstraction,
for very similar reasons as monads are powerful
for structuring programs.
Previously we saw that we could separate the happy path from our error handling,
it would appear that this separation is even more general with algebraic effects
and their handlers.

Finally we should note that
algebraic effects are particularly popular for systems programming
\cite{dolan2015effective, dolan2017concurrent, dolaneffectively};
especially in comparison to monads.
There are performance implications,
between a monadic or algebraic effect architecture,
for example recall the efficiency tax of a monad
transformer stack\cite{o2008real}.
Implementing concurrency through algebraic effects
is comparable, in terms of performance,
to the communicating sequential processes model of Go\cite{Dolan:2017}.
Combined with the first two benefits this may explain the
appeal of engineering large programs with algebraic effects.

With the benefits of algebraic effects extolled,
they may not be as elegant a tool as monads for structuring programs (yet).
Increased tooling and ecosystem maturity,
particularly around their use and verbosity,
could be beneficial.
Nevertheless algebraic effects
have immense potential because of
their simplicity and flexibility.

To approach the automatic convenience and fluidity of bind,
I would suggest the introduction of the keyword
\texttt{default\_with} which would provide a default
handler for each effect. While still
allowing the default handlers to be overridden
on a case by case basis.
Allowing the handlers to 
\begin{verbatim}
effect Result =
    | Return : 'a -> ()
    | Raise  : 'e -> ()
default_with
    | effect (Return v) -> Ok v
    | effect (Raise e) -> Err e
\end{verbatim}
Also note that this solves a common issue with
OCaml, there is no way to return early in a function
so one often has to hijack the current exception
system to emulate this behaviour.
If the above effect is defined all one would have
to do is call \texttt{perform (Return v)},
as long as the function is within a try clause and has
the return type \texttt{('a, 'e) result}.

Considering that we often see
\begin{verbatim}
effect Choose : bool
let choose () = perform Choose\end{verbatim}
or similarly
\begin{verbatim}
effect Put : t -> unit
let put v = perform (Put v)
\end{verbatim}
Another recommendation would be that it is likely
worthwhile to have this code generated via ppx, for example
\begin{verbatim}
effect Put : t -> unit [@@deriving perform_func]
\end{verbatim}

These suggestions are motivated by the fact that
given a choice between a perfect but inconvenient tool
and a imperfect but convenient tool
a programmer will the vast majority of the time choose the latter.
