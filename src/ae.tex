\section{Algebraic Effects}
Following from our discussion of Lawvere theories,
we will now explore their programming language progeny \textit{algebraic effects}.
The essence is
we have operations which generate effects,
which can be dealt with algebraically
%(What does algebraic mean
"A sloppy but intuitive way to describe this is "algebraic effects operate algebraically,
which is to say,
subject to purely local rewrites, or, alternately,
in such a way that the interpretation of an expression
can be given as an operator on the interpretation of its subexpressions."
Another, even more handwavy way to think of this,
is that handlers of algebraic effects are given via continuations.
So now, analogously to what happens when one tries to combine continuations
with exceptions in scheme, we run into the age-old conflict --
two mechanisms that both affect global control flow exist at once,
and have no particularly "good" way to not step on one another's toes.
cite internet

\subsection{Overview}


allowing the programmer to separate the expression of an effectful computation from its implementation."
\cite{dolan2015effective}
This is a benefit we saw with monads,
seperating the happy path from our error handling

Currently algebraic effects are a popular area of research,
and may well enter the mainstream in the next decade;
potentially because imperative programmers
will find them more intuitive equivalent monads.

Algebraic effects represent the cutting edge of effect management
in programming languages as such we have seen

\textbf{Some Algebraic Effect Implementations}
\begin{itemize}
    \item Eff: Matija Pretnar and Andrej Bauer, 2011-now.
    \item Links : Daniel Hillerström and Sam Lindley, 2015.
    \item Frank: Conor McBride, 2007, 2012.
    \item OCaml+effects: Stephen Dolan, Leo White, KC Sivaramakrishnan, 2016.
\end{itemize}

Algebraic effects, like monads, can be used to model effects in a pure language.
Where Moggi \cite{moggi1989computational} proposed monads to give categorical semantics to computational effects;
Power and Plotkin \cite{Plotkin:2002dw} propose "computational effects as being realised by
families of operations, with a monad being generated by their equational theory".
This means we can treat effects algebraically,
to actually interact with them as programming constructs algebraic effects are paired with
handlers \cite{plotkin2009handlers}.
Where algebraic operations construct effects handlers are the dual, they deconstruct effects.
"As a restriction on general monads, algebraic effects come with various advantages:
they can be freely composed,
\cite{leijen2017type}
They "provide a modular abstraction for expressing effectful computation"\cite{dolan2015effective},

\begin{example}
    Consider the examples of effects we gave at the beginning of this document.
    Each of these effects has a natural operation which generates the effect.
    Consider
    \begin{itemize}
        \item Input/Output \textit{generated by} \texttt{read, write}
        \item Mutable state \textit{generated by} \texttt{set, get}
        \item Exceptions \textit{generated by} \texttt{raise}
        \item Non-Determinism \textit{generated by the binary} \texttt{choose}
        \item Probabilistic Non-Determinism \textit{generated by} \texttt{random choice}
    \end{itemize}
\end{example}

Notice that we have not mentioned continuations here,
this is because
"continuations are computationally of a different character to other computational effects"
\cite{Plotkin:2002dw}.

"There are computationally natural families of operations associated with several of the above monads:
An analysis of several of thesefamiliesofoperationsappearsin[20]:
theyareregardedasalgebraicfami- lies of operations associated with an already given monad,
and are characterised intermsofgenericeffects:e.g.,
togiveagenericeffecte:nTmisequivalent togivingmn-aryalgebraicfamiliesofoperations,
wheremandnneednotbe finite(misthem-foldcoproductof1inC).
Cruciallywhenamonadisgiven byalgebraicoperationsandequationsinthesenseof,
thealgebraicfamilies of operations associated with it are given by the derived operations."
\cite{Plotkin:2002dw}

\begin{definition}
    An \textit{operation} is !
\end{definition}

\begin{definition}
    A \textit{generic effect} is
\end{definition}

\begin{example}
    Consider this example of an IO effect,
    first we define an effect \texttt{IO}
    and then describe two constructors
    \texttt{Print} and \texttt{Read}.
    To actually have an effect we use the primitive
    perform on an effect we construct, in this case with \texttt{Print}.
    \begin{verbatim}
        effect IO =
          | Print : string -> unit
          | Read : string

        perform (Print "Hello world");
    \end{verbatim}
\end{example}

\subsection{Handlers}
Thus far we have only
where operations are constructors of effects
we also need a dual,
\textit{handlers} which can be seen as deconstructors of effects
\cite{}.
Handlers were introduced by Plotkin and Pretner\cite{Plotkin:2009dr}
builds on
\cite{benton2001exceptional}
.

"Of the various operations, handle is of a different computational character and, although natural, it is not algebraic
Andrzej Filinski (personal communication) describes handle as a deconstructor, whereas the other operations are constructors (of effects). In this paper, we make the notion of constructor precise by identifying it with the notion of algebraic operation."
\cite{Plotkin:2002dw}

"presentanalgebraictreatmentofexceptionhandlersand, more generally, introduce handlers for other computational effects representable by an algebraic theory"
"Although the algebraic approach has given ways of constructing, combin- ing [10], and reasoning [22] about effects, it has not yet accounted for their handling. The difficulty is that exception handlers, a well-known programming concept, fail to be algebraic operations [20]. Conceptually, algebraic operations and effect handlers are dual: the former could be called effect constructors as they give rise to the effects; the latter could be called effect deconstructors as they depend on the effects already created. Filinski’s reflection and reification operations provide general effect constructors and deconstructors in the context of layered monads [5]."
"The central new semantic idea is that deconstructing a computation amounts to applying to it a unique homomorphism guaranteed by universality. The domain of this homomorphism is a free model of the algebraic theory of the effects at hand; its range is a programmer-defined model of the algebraic theory; and it extends a programmer- defined map on values."
"exceptions provide the simplest example of algebraic effects"
%Taking a set of exceptions E, the computations that return values from a set X are modelled by elements γ of the monad T X =def X + E with unit ηX = inlX : X → X + E. Algebraically, one may take a nullary operation, i.e., a constant, raisee : 0 for each e ∈ E and no equations, and then F X has carrier TX with raisee interpreted as inr(e).
%Fixing X, an exception handler γhandle{e􏰀→γe}e∈E takes a computation γ ∈ X + E and intercepts raised exceptions e ∈ E, carrying out predefined computations γe ∈ X + E instead (if one chooses not to handle a particular exception e one takes γe = raisee). So we have the two equations:
%ηX(x)handle{e􏰀→γe}e∈E =inlX(x),
%raisee handle {e 􏰀→ γe}e∈E = γe .
%From an algebraic point of view, the γe provide a model X + E for the theory of exceptions. This model has carrier X + E and, for each e, raisee is interpreted by γe. We then see from the above two equations that
%θ(γ)=def γhandle{e􏰀→γe}e∈E
%is the unique homomorphism θ : X + E → X + E extending inlX : X → X + E along ηX (we confuse the free model on X with its carrier).
\cite{Plotkin:2009dr}
builds on
\cite{benton2001exceptional}


"Plotkin and Pretnar’s handlers for algebraic effects occupy a sweet spot in the design space of abstractions for effectful computation. By separating effect signatures from their implementation, alge- braic effects provide a high degree of modularity, allowing pro- grammers to express effectful programs independently of the con- crete interpretation of their effects. A handler is an interpretation of the effects of an algebraic computation. The handler abstraction adapts well to multiple settings: pure or impure, strict or lazy, static types or dynamic types."
"In general an abstract operation declaration has the form
%[operation | ∀u1 ... ul.Op e1 ... em :: A1 → ... → An → A |]
%where Op is the name of the operation, u1 , ..., ul are universal type variables, e1,...,em are existential type variables, A1,...,An are parameter types, and A is the return type. "
\cite{kammar2013handlers}

A key benefit of handlers, and hence of algebraic effects,
is that

and there is a natural separation between
their interface (as a set of operations)
and
their semantics (as a handler)."
"the signature of the effect operations forms a free algebra which gives rise to a free monad.
Free monads provide a natural way to give semantics to effects,
where handlers describe a fold over the algebra of operations.
Using a more operational perspective,
we can also view algebraic effects as resumable exceptions
(or perhaps as a more structured form of delimited continuations)."
\cite{leijen2017type}

Monad transformers can quickly become unwieldy when there are lots of effects to manage,
leading to a temptation in larger programs to combine everything into one coarse-grained state and exception monad.
[Programming and Reasoning with Algebraic Effects and Dependent Types]

Algebraic effects are computational effects that can be represented by an equational theory, or algebraic theory, whose operations produce the effects at hand.
Continuations are not algebraic effects.

Algebraic effects allow computational effects to be representable by
effects that allow a representation by operations and equations

\subsection{Structuring Programs with Algebraic Effects}
As we demonstrated monads are rather useful for structuring programs,
allowing us to only consider the happy path while remaining assured
edge cases are handled;
it is natural to ask if programming with algebraic effects
has the same properties?

Recall our implementation of a trie with monads,
we will now explore whether an algebraic effect implementation
\begin{verbatim}
  let get t key =
    let rec search chars t =
        match chars with
        | []      -> val_extract t
        | c :: cs -> bind_search (find_child t c) cs
    and bind_search ot chars = ot >>= search chars
    in search key t
\end{verbatim}

We can also recall the implementation of the state monad

\begin{verbatim}
class Monad m => MonadState s m | m -> s where
    -- | Return the state from the internals of the monad.
    get :: m s
    get = state (\s -> (s, s))

    -- | Replace the state inside the monad.
    put :: s -> m ()
    put s = state (\_ -> ((), s))

    -- | Embed a simple state action into the monad.
    state :: (s -> (a, s)) -> m a
    state f = do
      s <- get
      let ~(a, s') = f s
      put s'
      return a

join :: (State s (State s a)) -> (State s a)
join xss = State (\s -> uncurry runState (runState xss s))

type GameValue = Int
type GameState = (Bool, Int)

playGame :: String -> State GameState GameValue
playGame []     = do
    (_, score) <- get
    return score

playGame (x:xs) = do
    (on, score) <- get
    case x of
         'a' | on -> put (on, score + 1)
         'b' | on -> put (on, score - 1)
         'c'      -> put (not on, score)
         _        -> put (on, score)
    playGame xs

startState = (False, 0)

main = print $ evalState (playGame "abcaaacbbcabbab") startState
\end{verbatim}

\begin{example}
\end{example}

\subsection{Composing Algebraic Effects}
What has become the most evident deficiency of monads is
how difficult it is to compose them.
Composability is often touted as one the most
prominent advantages of functional programming

How to compose algebraic effects?
\begin{example}
\end{example}

\subsection{Comparison with Monads}
lots of ppl say the monads when composed make effects coarse grained
and this is ugly

OCaml is impure but has monads, and soon effects, wen you need them?
is this the most 'pratical' approach?

algebraic effects are more scalable solution for engineering programs!
\begin{verbatim}
effect choice =
  | Choose : bool

effect int_state =
  | Get : int
  | Set : int -> unit

effect scheduler =
  | Spawn : (unit -> unit) -> unit
  | Yield : unit

let incr_twice () : int =
  perform (Set ((perform Get) + 1));
  perform (Set ((perform Get) + 1));
  perform (Print "incremented twice");
  perform Get
\end{verbatim}

"Monad transformers [25] provide a form of modular instantia- tion for abstract monadic computations. For instance, state can be handled in the presence of other effects by incorporating a state monad transformer within a monad transformer stack.
A fundamental problem with monad transformer stacks is that once a particular abstract effect is instantiated, the order of effects in the stack becomes concrete, and it becomes necessary to explic- itly lift operations through the stack. Taming the monad transformer stack is an active research area [16, 17, 38, 42]."
\cite{kammar2013handlers}
%http://gallium.inria.fr/~scherer/doc/effect-handlers-talk.html#/sec-effect-handlers--examples

A potential advantage of algebraic effects over monads is that
the "
notion of countable enriched Lawvere theory
provides us with a natural way to describe
how computational effects may be combined.
"
\cite{plotkin2004computational}.
I.e. algebraic effects compose more naturally.
