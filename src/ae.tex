\section{Algebraic Effects}
Following from our discussion of Lawvere theories,
we will now explore their programming language progeny \textit{algebraic effects}.
The essence is we have \textit{operations} which generate effects,
and to actually interact with them as programming constructs
we need \textit{handlers}\cite{plotkin2009handlers};
which, informally, deconstruct effects.
This section will cover these two issues and their use.

For a casual understanding,
we can begin to explain algebraic effects by saying that
we have effects we can manipulate algebraically; that is to say,
the interpretation of an expression is
subject to an operator and its sub-expressions.
For instance, $a + b$ is interpreted as an operator
$+$ with its own semantics along with the value of its
two sub-expressions $a$ and $b$.
As our first example, consider the maybe monad where we have
\texttt{Nothing | Just x},
this monad is generated by
\begin{equation}
    raise :: 0 \rightarrow 1
\end{equation}
a nullary (of zero arguments) operator with no sub-expressions.

We can further our initial understanding with another view
relating algebraic effects to continuations,
or rather algebraic effects being given by continuations.
Whenever an operation is performed we have a continuation
passed to the handler;
which the handler uses to "implement" that effect.
This view also allows us an initial but intuitive
understanding as to why algebraic effects are incompatible with continuations;
it is not possible to distribute global control flow across several mechanisms.

However algebraic effects are not simply just continuations,
they are programmer defined effects.
To the programmer perhaps this is perhaps the most interesting implication,
we can now have programmer defined effects,
moreover potentially specifying multiple handlers for each effect.
Previously effects were completely implicit,
and this is a large reason why they can cause bugs,
now they are under direct and explicit control of the programmer.

Currently algebraic effects are a popular area of research,
as such we have seen a multitude of implementations in recent years.
They may well enter the mainstream (as mainstream as monads at least)
due to multicore OCaml being implemented in terms of algebraic effects.
Additionally, it is likely that imperative programmers
will find algebraic effects more intuitive than an equivalent monads.

\textbf{Some Algebraic Effect Implementations}
\begin{itemize}
    \item Eff: Matija Pretnar and Andrej Bauer,
        2015\cite{bauer2015programming}
    \item Frank: Sam Lindley and Conor McBride
        2016\cite{Lindley:2016vz}
    \item OCaml+effects: Stephen Dolan, Leo White, KC Sivaramakrishnan,
        2016\cite{ocamlplseff}
    \item Koka: Dan Leijen
        2016\cite{leijen:16}
\end{itemize}

\subsection{Overview}
\begin{example}
    Recall the examples of effects we gave at the beginning of this document,
    each of these effects has a natural operation which generates the effect.
    Consider
    \begin{itemize}
        \item Input/Output \textit{generated by} \texttt{read, write}
        \item Mutable state \textit{generated by} \texttt{set, get}
        \item Exceptions \textit{generated by} \texttt{raise}
        \item Non-Determinism \textit{generated by} \texttt{choose}
        \item Probabilistic Non-Determinism \textit{generated by} \texttt{choice}
    \end{itemize}
\end{example}

Notice that continuations are not mentioned here,
this is because, as discussed previously,
continuations are of a computationally different character
than these other effects
\cite{Plotkin:2002dw}\cite{hyland2007combining}.

Let us examine input and output as an algebraic effect in detail,
we will begin with the quintessential programming example; "Hello world!".
We will be working in OCaml+effects\cite{ocamlplseff} for this example,
using code from \cite{kceff}.\\

\begin{example}
    Consider this example of an IO effect,
    first we define an effect \texttt{IO},
    this is, in OCaml, similar to defining
    a new exception type.
    We then describe two constructors
    \texttt{Print} and \texttt{Read}
    of the effect \texttt{IO}.
    \begin{verbatim}
        effect IO =
          | Print : string -> unit
          | Read : string\end{verbatim}
    Now to actually have an effect we need to use the primitive \texttt{perform},
    we construct an effect via \texttt{(Print "Hello world!")}.
    \begin{verbatim}
        let print_hello () =
            perform (Print "Hello world!")\end{verbatim}
    Because OCaml is impure, the handler of this effect looks rather obtuse,
    however in a pure or lazy language this effect and handler would be necessary.
    Here it is just an indirection for the sake of an example.
    \begin{verbatim}
        let main () =
          try print_hello () with
          | effect (Print s) k -> printf s ^ "\n"; continue k\end{verbatim}
\end{example}

\subsection{Handlers}
Thus far we have only seen how to perform effects,
we need a mechanism by which to give these operations semantics.
Where operations are constructors of effects we also need a dual,
\textit{handlers} can be seen as deconstructors of effects\cite{Plotkin:2002dw}.

Handlers were introduced by Plotkin and Pretner\cite{Plotkin:2009dr},
the new handling construct generalises the exception-handling
construct of Benton and Kennedy\cite{benton2001exceptional}.
The key difference between typical exception handlers
and algebraic effect handlers is that
there is a continuation allowing for arbitrary effects to be expressed.

Handlers present one of the greatest benefits of algebraic effects;
"by separating effect signatures from their implementation,
algebraic effects provide a high degree of modularity"\cite{kammar2013handlers}.
Modularity is always important when engineering software
and allowing programmers to create an interface between
the expression of an effectful computation
and the concrete interpretation of their effects.

\subsection{Composing Algebraic Effects}
What has become the most evident deficiency of monads is
how difficult and tricky it is to compose them.
This is particularly unpleasant as
composability is often touted as one the most practical advantages of functional programming.
Fortunately composing algebraic effects is much less complicated than composing monads!
There exists an intuitive way to compose algebraic effects,
for example one doesn't need to consider order of composition as one does with monads.
This advantage stems from the theory in fact,
the "notion of countable enriched Lawvere theory
provides us with a natural way to describe
how computational effects may be combined
"\cite{plotkin2004computational}.

Another example of algebraic effects is binary non-determinism,
here we simulate a coin flip.\\
\begin{example}\begin{verbatim}

    effect choice = Choose : bool

    let coin_flip () =
        if (perform Choose) then
            Heads
        else
            Tails

    try coin_flip () with
    | effect Choose k -> continue k (Random.bool ())
    \end{verbatim}
\end{example}
Now let us tackle the question of how to actually compose
algebraic effects.\\

\begin{example}
    Recall our IO and non-determinism examples,
    we can combine them with ease!
\begin{verbatim}
    effect IO =
    | Print : string -> unit
    | Read : string

    effect choice =
    | Choose : bool

    effect int_state =
    | Get : int
    | Set : int -> unit

    let incr_maybe_twice () : int =
      perform (Set ((perform Get) + 1));
      if (perform Choose)
      then perform (Set ((perform Get) + 1))
      else perform (Print "incremented just once");
      perform Get
\end{verbatim}
    We simply need to add a handler for each effect we incorporate.
\begin{verbatim}
      match incr_maybe_twice () with
      | result -> result
      | effect (Put s') k -> (fun s -> continue k () s')
      | effect Get k -> (fun s -> continue k s s)
      | effect (Print s) k -> printf s; continue k
      | effect Choose k -> continue k (Random.bool ())


  let run f ~init =
    let comp =
      match f () with
      | x -> (fun s -> (s, x))
      | effect (Put s') k -> (fun s -> continue k () s')
      | effect Get k -> (fun s -> continue k s s)
    in comp init
\end{verbatim}
\end{example}

%TODO FIx EFFECTS EXANPLES!!!!!!!!!!!!
Of course having one global handler is neither elegant nor simple,
we are free to handle effects at any point in the call stack,
consider this example
\begin{verbatim}
    let incr_thrice () : int =
        let incr_aux () =
            perform Set ((perform Get) + 1);
            perform Set ((perform Get) + 1);
            perform Set ((perform Get) + 1)
        in
        match incr_aux () with
        | effect (Put s') k -> (fun s -> continue k () s')
        | effect Get k -> (fun s -> continue k s s)

    let incrx3_maybe () : int =
        let aux () =
            if (perform Choose)
            then incr_thrice ()
            else perform_get ()
        in
        match aux () with
        | effect Choose k -> continue k (Random.bool ())
\end{verbatim}

\subsection{Structuring Programs with Algebraic Effects}
As we demonstrated monads are rather useful for structuring programs,
for example,
allowing us to only consider the happy path while remaining assured
edge cases are handled;
it is natural to ask if programming with algebraic effects
has the same properties?

Recall our implementation of a trie with monads,
we will now explore whether an algebraic effect implementation
\begin{verbatim}
  let get t key =
    let rec search chars t =
        match chars with
        | []      -> val_extract t
        | c :: cs -> (find_child t c) >>= searh cs
    in search key t
\end{verbatim}

Contrast this with an algebraic effect implementation

\begin{verbatim}
  effect exception = Exn

  let get t key =
    let rec search chars t =
        match chars with
        | []      -> val_extract t
        | c :: cs -> search_children t c cs
    and search_children t c chars =
        match find_child t c with
        | None -> perform Exn
        | Some -> search chars
    in try search key t with
    | effect Exn _ -> None
    | value -> value
\end{verbatim}

We can immediately see that this implementation is more verbose,
which is not necessarily desirable;
however the mechanisms of how this function works
are more apparent.
%TODO Ugh pls struct w ae

\subsection{Conclusion}
There are two core benefits of algebraic effects.
Firstly, composition of algebraic effects is simple and pain free;
we will examine this later.
Secondly they allow a seperation between
"the expression of an effectful computation from its implementation"
\cite{dolan2015effective}.
%TODO Expl more here pls
This is a powerful tool of modular abstraction,
for very similar reasons as monads are powerful
for structuring programs.
Previously we saw that we could separate the happy path from our error handling,
it would appear that this separation is even more general with algebraic effects
and their handlers.
%TODO explain eff impl seper
%We can separate an effect from its implementation,

Finally we should note that
algebraic effects are particularly popular for systems programming
\cite{dolan2015effective, dolan2017concurrent, dolaneffectively};
especially in comparison to monads.
This is particularly due to performance implications,
implementing concurrency through algebraic effects
is comparable to the communicating sequential processes model
of Go in terms of performance \cite{Dolan:2017}.
This performance aspect is more striking
if we consider the efficiency tax of a monad
transformer stack\cite{o2008real}.

Algebraic effects may not be as elegant a tool as monads for structuring programs,
but it is undeniable they are far more composable and more efficient.
Thus they are more powerful tools for certain effects,
for example concurrency.

%lots of ppl say the monads when composed make effects coarse grained
%and this is ugly
%OCaml is impure but has monads, and soon effects, wen you need them?
%is this the most 'practical' approach?
algebraic effects are more scalable solution for engineering programs!
this maybe one of the reasons why they seem to be so popular in systems
programming

especially in comparison to monads.
This is particularly due to performance implications,
implementing concurrency through algebraic effects
is comparable to the communicating sequential processes model
of Go in terms of performance \cite{Dolan:2017}.
This performance aspect is more striking
if we consider the efficiency tax of a monad
transformer stack\cite{o2008real}.

Algebraic effects are currently an
immature programming language construct
however have immense potential because of 
their simplicity and flexibility.

Would suggest automatic handlers,
which would make the automatic behavuour of bind
available to algebraic effects
\begin{verbatim}
effect Result =
    | Return : 'a -> ()
    | Raise  : 'e -> ()
with default try
    | effect (Return v) -> Ok v
    | effect (Raise e) -> Err e
\end{verbatim}
Also note that this solves a common issue with
OCaml, there is no way to return early in a function
so one often has to hijack the current exception
system to emulate this behaviour.

Consider that we often see
\begin{verbatim}
effect Choose : bool
let choose () = perform Choose\end{verbatim}
or similarly
\begin{verbatim}
effect Put : t -> unit
let put v = perform (Put v)
\end{verbatim}
Perhaps it would be worthwhile to have this code
generated via ppx, for example
\begin{verbatim}
effect Put : t -> unit [@@deriving fun]
\end{verbatim}

These suggestions are motivated by the fact that
given a choice between a perfect but inconvenient tool
and a imperfect but convenient tool
a programmer will the vast majority of the time choose the latter.


