\section{Algebraic Effects}
Following from our discussion of Lawvere theories,
we will now explore their programming language progeny \textit{algebraic effects}.
The essence is we have \textit{operations} which generate effects,
and to actually interact with them as programming constructs
we need \textit{handlers}\cite{plotkin2009handlers};
which, informally, deconstruct effects.
This section will cover these two issues and their use.

For a casual understanding,
we can begin to explain algebraic effects by saying that
we have effects we can manipulate algebraically; that is to say,
the interpretation of an expression is
subject to an operator and its sub-expressions.
For instance, $a + b$ is interpreted as an operator
$+$ with its own semantics along with the value of its
two sub-expressions $a$ and $b$.
As our first example, consider obtaining input from
\texttt{stdin} using the operation \texttt{read} where
\begin{equation}
    read :: \texttt{()} \rightarrow IO\ String
\end{equation}
as a nullary (of zero arguments) operator with no sub-expressions.

We can further our initial understanding with another view
relating algebraic effects to continuations,
or rather algebraic effects being given by continuations.
Whenever an operation is performed we have a continuation
passed to the handler;
which the handler uses to "implement" that effect.
This view also allows us an initial but intuitive
understanding of why algebraic effects are incompatible with continuations;
it is not possible to distribute global control flow across several mechanisms.

However algebraic effects are not simply just continuations,
they are programmer defined effects.
To the programmer perhaps this is perhaps the most interesting implication,
we can now have programmer defined effects,
moreover potentially specifying multiple handlers for each effect.
Previously effects were completely implicit,
and this is a large reason why they can cause bugs,
now they are under direct and explicit control of the programmer.

Currently algebraic effects are a popular area of research,
as such we have seen a multitude of implementations in recent years.
They may well enter the mainstream (as mainstream as monads at least)
due to multicore OCaml being implemented in terms of algebraic effects.
Additionally, it is likely that imperative programmers
will find algebraic effects more intuitive than an equivalent monads.

\textbf{Some Algebraic Effect Implementations}
\begin{itemize}
    \item Eff: Matija Pretnar and Andrej Bauer,
        2015\cite{bauer2015programming}
    \item Frank: Sam Lindley and Conor McBride
        2016\cite{Lindley:2016vz}
    \item OCaml+effects: Stephen Dolan, Leo White, KC Sivaramakrishnan,
        2016\cite{ocamlplseff}
    \item Koka: Dan Leijen
        2016\cite{leijen:16}
\end{itemize}

\subsection{Overview}
\begin{example}
    Recall the examples of effects we gave at the beginning of this document,
    each of these effects has a natural operation which generates the effect.
    Consider
    \begin{itemize}
        \item Input/Output \textit{generated by} \texttt{read, write}
        \item Mutable state \textit{generated by} \texttt{set, get}
        \item Exceptions \textit{generated by} \texttt{raise}
        \item Non-Determinism \textit{generated by} \texttt{choose}
        \item Probabilistic Non-Determinism \textit{generated by} \texttt{choice}
    \end{itemize}
\end{example}

Notice that continuations are not mentioned here,
this is because, as discussed previously,
continuations are of a computationally different character
than these other effects
\cite{Plotkin:2002dw}\cite{hyland2007combining}.

Let us examine input and output as an algebraic effect in detail,
we will begin with the quintessential programming example; "Hello world!".
We will be working in OCaml+effects for this example.\\

\begin{example}
    Consider this example of an IO effect,
    first we define an effect \texttt{IO},
    this is, in OCaml, similar to defining
    a new exception type.
    We then describe two constructors
    \texttt{Print} and \texttt{Read}
    of the effect \texttt{IO}.
    \begin{verbatim}
        effect IO =
          | Print : string -> unit
          | Read : string\end{verbatim}
    Now to actually have an effect we need to use the primitive \texttt{perform},
    we construct an effect via \texttt{(Print "Hello world!")}.
    \begin{verbatim}
        let print_hello () =
            perform (Print "Hello world!")\end{verbatim}
    Because OCaml is impure, the handler of this effect looks rather obtuse,
    however in a pure or lazy language this effect and handler would be necessary.
    Here it is just an indirection for the sake of an example.
    \begin{verbatim}
        let main () =
          try print_hello () with
          | effect (Print s) k -> printf s ^ "\n"; continue k\end{verbatim}
\end{example}

Following our first detailed example,
we should state that there are two core benefits of algebraic effects.
Firstly, composition of algebraic effects is simple and pain free;
we will examine this later.
Secondly they allow a seperation between
"the expression of an effectful computation from its implementation"
\cite{dolan2015effective}.
%TODO Expl more here pls
This is a powerful tool of modular abstraction,
for very similar reasons as monads are powerful
for structuring programs.
Previously we saw that we could separate the happy path from our error handling,
it would appear that this separation is even more general with algebraic effects
and their handlers.
%TODO explain eff impl seper
%We can separate an effect from its implementation,

Finally we should note that
algebraic effects are particularly popular for systems programming
\cite{dolan2015effective, dolan2017concurrent, dolaneffectively};
especially in comparison to monads.
This is particularly due to performance implications,
implementing concurrency through algebraic effects
is comparable to the communicating sequential processes model
of Go in terms of performance \cite{Dolan:2017}.
This performance aspect is more striking
if we consider the efficiency tax of a monad
transformer stack\cite{o2008real}.

\subsection{Handlers}
Thus far we have only
where operations are constructors of effects
we also need a dual,
\textit{handlers} which can be seen as deconstructors of effects
\cite{}.
Handlers were introduced by Plotkin and Pretner\cite{Plotkin:2009dr}
builds on
\cite{benton2001exceptional}.

new handling construct generalises the exception-handling construct of Benton and Kennedy. \cite{benton2001exceptional}

"Of the various operations, handle is of a different computational character and,
although natural, it is not algebraic
Andrzej Filinski (personal communication) describes handle as a deconstructor,
whereas the other operations are constructors (of effects)"
\cite{Plotkin:2002dw}

"present an algebraic treatment of exception handlers and,
more generally, introduce handlers for other computational effects
representable by an algebraic theory"
"Although the algebraic approach has given ways of constructing,
combining, and reasoning about effects, it has not yet accounted for their handling.


The difficulty is that exception handlers, a well-known programming concept,
fail to be algebraic operations.

Conceptually, algebraic operations and effect handlers are dual:
the former could be called effect constructors as they give rise to the effects;
the latter could be called effect deconstructors as they depend on the effects already created.

Filinski’s reflection and reification operations provide general effect constructors
and deconstructors in the context of layered monads [5]."

"The central new semantic idea is that deconstructing a computation amounts to
applying to it a unique homomorphism guaranteed by universality.
The domain of this homomorphism is a free model of the algebraic theory of the effects at hand;
its range is a programmer-defined model of the algebraic theory;
and it extends a programmer-defined map on values."
\cite{Plotkin:2009dr}


"Plotkin and Pretnar’s handlers for algebraic effects occupy a sweet spot in the design space of abstractions for effectful computation. By separating effect signatures from their implementation, alge- braic effects provide a high degree of modularity, allowing pro- grammers to express effectful programs independently of the con- crete interpretation of their effects. A handler is an interpretation of the effects of an algebraic computation. The handler abstraction adapts well to multiple settings: pure or impure, strict or lazy, static types or dynamic types."
\cite{kammar2013handlers}

A key benefit of handlers, and hence of algebraic effects,
is that

Generalised exception handlers. Benton and Kennedy [3] intro- duced the idea of adding a return continuation to exception han- dlers. Their return continuation corresponds exactly to the return clause of an effect handler. Effect handler operation clauses gener- alise exception handler clauses by adding a continuation argument, providing support for arbitrary effects. An operation clause that ig- nores its continuation argument behaves like a standard exception handler clause.

and there is a natural separation between
their interface (as a set of operations)
and
their semantics (as a handler)."
"the signature of the effect operations forms a free algebra which gives rise to a free monad.
Free monads provide a natural way to give semantics to effects,
where handlers describe a fold over the algebra of operations.
Using a more operational perspective,
we can also view algebraic effects as resumable exceptions
(or perhaps as a more structured form of delimited continuations)."
\cite{leijen2017type}

\subsection{Composing Algebraic Effects}
What has become the most evident deficiency of monads is
how difficult and tricky it is to compose them.
This is particularly unpleasant as
composability is often touted as one the most practical advantages of functional programming.
Fortunately composing algebraic effects is much less complicated than composing monads!
There exists an intuitive way to compose algebraic effects,
for example one doesn't need to consider order of composition as one does with monads.
This advantage stems from the theory in fact,
the "notion of countable enriched Lawvere theory
provides us with a natural way to describe
how computational effects may be combined
"\cite{plotkin2004computational}.

Another example of algebraic effects is binary non-determinism,
here we simulate a coin flip.\\

\begin{example}\begin{verbatim}

    effect choice = Choose : bool

    let coin_flip () =
        if (perform Choose) then
            Heads
        else
            Tails

    try coin_flip () with
    | effect Choose k -> continue k (Random.bool ())
    \end{verbatim}
\end{example}
Now let us tackle the question of how to actually compose
algebraic effects.\\

\begin{example}
    Recall our IO and non-determinism examples,
    we can combine them with ease!
    \begin{verbatim}
        effect IO =
          | Print : string -> unit
          | Read : string

        effect choice =
          | Choose : bool

        effect int_state =
          | Get : int
          | Set : int -> unit

        let incr_maybe_twice () : int =
          perform (Set ((perform Get) + 1));
          if (perform Choose)
          then perform (Set ((perform Get) + 1))
          else perform (Print "incremented just once");
          perform Get
    \end{verbatim}
    We simply need to add a handler for each effect we incorporate.
    \begin{verbatim}
          match incr_maybe_twice () with
          | result -> result
          | effect (Put s') k -> (fun s -> continue k () s')
          | effect Get k -> (fun s -> continue k s s)
          | effect (Print s) k -> printf s; continue k
          | effect Choose k -> continue k (Random.bool ())
    \end{verbatim}
\end{example}

%TODO restruc comp AE
Of course having one global handler is neither elegant nor simple,
so we restructure our example

\subsection{Structuring Programs with Algebraic Effects}
As we demonstrated monads are rather useful for structuring programs,
for example,
allowing us to only consider the happy path while remaining assured
edge cases are handled;
it is natural to ask if programming with algebraic effects
has the same properties?

Recall our implementation of a trie with monads,
we will now explore whether an algebraic effect implementation
\begin{verbatim}
  let get t key =
    let rec search chars t =
        match chars with
        | []      -> val_extract t
        | c :: cs -> (find_child t c) >>= searh cs
    in search key t
\end{verbatim}

Contrast this with an algebraic effect implementation

\begin{verbatim}
  effect exception = Exn

  let get t key =
    let rec search chars t =
        match chars with
        | []      -> val_extract t
        | c :: cs -> search_children t c cs
    and search_children t c chars =
        match find_child t c with
        | None -> perform Exn
        | Some -> search chars
    in try search key t with
    | effect Exn _ -> None
    | value -> value
\end{verbatim}

We can immediately see that this implementation is more verbose,
which is not necessarily desirable;
however the mechanisms of how this function works
are more apparent.

Next we shall consider an example
To illustrate the purpose of this function here
is an example of two variables.
It generates $2^n$ where $n = 2$

\begin{verbatim}
    type t =
        | And   of t * t
        | Or    of t * t
        | Not   of t
        | Var   of var
        | Const of bool
    type var = string
    type ctxt = (var * bool) list

    gen_ctxts ["a";"b"];;
    - : (string * bool) list list = [
        [("a", true);  ("b", true)];
        [("a", true);  ("b", false)];
        [("a", false); ("b", true)];
        [("a", false); ("b", false)]
    ]
\end{verbatim}

Here is a straightforward implementation
\begin{verbatim}
  let gen_ctxts vars =
    let push ctxt v b = List.map ctxt ~f:(fun x -> (v, b) :: x) in
    let rec aux vs = match vs with
      | [] -> []
      | [v] -> [[v, true]; [v, false]]
      | v :: vs ->
        let vs' = aux vs in
        (push vs' v true) @ (push vs' v false)
    in aux vars
\end{verbatim}

\begin{verbatim}
  let gen_ctxts vars : var list -> (var * bool) list list =
    let push ctxt v b = List.map ctxt ~f:(fun x -> (v, b) :: x) in
    let rec aux vs = match vs with
      | [] -> []
      | [v] -> [[v, true]; [v, false]]
      | v :: vs ->
        let vs' = aux vs in
        (push vs' v true) @ (push vs' v false)
    in aux vars
\end{verbatim}
Consider the algebraic effect version
%TODO AE Non-det

\begin{verbatim}
  let gen_ctxts vars =
    let push ctxt v b = List.map ctxt ~f:(fun x -> (v, b) :: x) in
    let rec aux vs = match vs with
      | [] -> []
      | [v] -> [[v, true]; [v, false]]
      | v :: vs ->
        let vs' = aux vs in
        let b = perform Choose in
        push vs' v b
    in aux vars

    let all_results vars =
      match gen_ctxts vars with
      | result -> result
      | effect Choose k ->
         (continue k true) @ (continue (Obj.clone_continuation k) false)
         (* OCaml effects/multicore only supports single-shot
           continuations. But, we can simulate multi-shot continuations by
           copying a continuation (using Obj.clone) before invocation. *)
\end{verbatim}

\subsection{Comparison with Monads}
Algebraic effects may not be as elegant a tool as monads
for structuring programs,
it is undeniable they are far more composable
and more efficient.
"
A fundamental problem with monad transformer stacks is that
once a particular abstract effect is instantiated,
the order of effects in the stack becomes concrete,
and it becomes necessary to explicitly lift operations
through the stack."
\cite{kammar2013handlers}
Monad transformers can quickly become unwieldy when there are lots of effects to manage,
leading to a temptation in larger programs to combine everything into one coarse-grained state and exception monad.
\cite{brady2013programming}
lots of ppl say the monads when composed make effects coarse grained
and this is ugly
OCaml is impure but has monads, and soon effects, wen you need them?
is this the most 'practical' approach?
algebraic effects are more scalable solution for engineering programs!
this maybe one of the reasons why they seem to be so popular in systems
programming


"Moreover, effect handlers allow concurrent programs to be written in direct-style retaining the simplicity of sequential code as opposed to callback-oriented style with either monadic concurrency libraries such as Lwt [8] and Async [5] for OCaml or explicit callbacks."
\cite{dolaneffectively}
Finally we should note that
algebraic effects are particularly popular for systems programming
\cite{dolan2015effective, dolan2017concurrent, dolaneffectively};
especially in comparison to monads.
This is particularly due to performance implications,
implementing concurrency through algebraic effects
is comparable to the communicating sequential processes model
of Go in terms of performance \cite{Dolan:2017}.
This performance aspect is more striking
if we consider the efficiency tax of a monad
transformer stack\cite{o2008real}.

